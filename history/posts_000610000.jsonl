{"id": "YAACjU8e-3s7eyxURacJi3GxjplFNJKEZipfyIQ3gks", "title": "Crypto and Blockchain Governance Resources", "body": "This is my running list of crypto and blockchain governance resources here. I'll annotate them as well, as I find the time and attention to review them.\n\n[[Proposal] SourceCred Engagement Incentives](https://forum.balancer.finance/t/proposal-sourcecred-engagement-incentives/684) by [Coopahtropa](https://twitter.com/Cooopahtroopa) on the Balancer forum\n\n[Ten Theses on Decentralized Network Governance](https://www.placeholder.vc/blog/2020/9/30/ten-theses-on-decentralized-network-governance) by [Mario Laul](https://twitter.com/mlphresearch) on the Placeholder VC blog.\n\n*P.S. - [Contact me](https://chainflow.io/staking) if you'd like to talk governance strategy for your staking project. I have real world experience building DAO tools and living the governance process as a core team member and validator with projects and on networks that have significant user bases.*\n\n", "timestamp": 1611066294, "digest": "xdUczMv13E4se9kxQfxi5V3_T8gPektt4oIPcAMfeAA", "contributor": "0x53b91350a481C1ad80f12127d10524793c9a7E89"}
{"id": "daDHxDCNDAZWILV2UyjXRbvWVvKlhUBHPyUZxq0gu6g", "title": "Crowdfunding Writing with NFTs", "body": "Monetization of publicly accessible written content has never had a strong basis on the internet, since it suffers from the [public goods](https://en.wikipedia.org/wiki/Public_good) problem. As publishing has moved online, funding for high-quality, long-form writing has broken down.\n\nNFTs give us new tools to solve this problem — by a representing previously infinitely reproducible creative works as scarce, tradable digital assets. This means that artists can now *sell* a scarce digital asset representing an essay as a unique collectible or artwork, while the content itself remains open and freely accessible (a public good). Still, the problem remains for funding the time and work necessary for a creator to produce impactful writing. \n\nWe imagine a world where writers on Mirror can publish an intention to research and produce high-quality writing, and receive crowdsourced funding. In this model, the contributors who fund the project also receive a stake in the future financial upside produced by the work, captured by subsequent sales of the NFT. This improves considerably on existing crowdfunding platforms, such as Kickstarter.\n\nTo achieve these outcomes, the content must be tradable as a single artifact (an NFT), and the ownership of that artifact must be fractional — allowing multiple people to own a small stake. By using Ethereum as the economic infrastructure, we can allow tradable, fractional ownership of the NFT using ERC20 tokens.\n\nThe funders of the project should be able to trade their own currency (e.g. ETH or DAI) for an ownership stake before the project is completed. The creator should be able to withdraw pledged funds and use them to fund the production of the public good. The backers should be allowed to redeem the underlying funds (including profits) once the NFT is traded, proportional to the percent that they contributed to the fund. They can do this by provably burning their equity tokens in a single transaction that also redeems their funds. \n\nSince equity is represented as an ERC20, contributors might also trade their tokens on an exchange like Uniswap, instead of redeeming the underlying value — similar to trading options.\n\nIn the future, we imagine that the creator could be the operator of a DAO that produces many works, each of minted as an NFT, with ongoing revenue from trading accruing back to the DAO. Funders of the DAO can therefore expect profits beyond those coming from sales of the first NFT.\n\nThis could signal the beginning of a movement towards journalist and artist DAOs.\n\nIn this post, we include our technical considerations for this project and a sketch of the contract that might serve this purpose. We welcome any and all feedback on our ideas. We will target a demo of the working functionality on Friday during a live-stream.\n\n![](https://images.mirror-media.xyz/publication-images/1cddf105-e9c1-4a79-b72a-9daf4be83712.jpeg?height=1504&width=1348)\n\n## Problems We're Solving\n\n- Writers want funding for a long-form piece of content before writing it\n- Contributors want to fund their favorite writers, and receive some return on their investment\n- Contributors want to be recognized as patrons of public goods\n- Speculators want to invest in NFTs, including those that represent *written* works\n- Nobody wants to pay excessive gas costs that make it unprofitable to solve these problems\n\n## What Success Looks Like\n\n- Contributors can exchange currency (e.g. ETH) for some ownership stake in a future work\n- The Creator can withdraw the funds that are raised, and thereby close the funding session\n- The work is represented by a tradable NFT\n- The Creator can update the NFT's metadata once the work is finished\n- The Creator can trade that NFT for a profit\n- Contributors can trade their ownership stake on Uniswap\n- Contributors can divest their stake for accumulated revenue\n- The Creator can receive an ownership stake once the funding is closed, entitling them to a share of the future profits as well\n\n## Out of Scope\n\n- Bringing this into the scope of the *Publication Contract*, and thereby blocking experimentation on that work-stream.\n\n## Implementation Summary\n\n- There is an ERC20-compatible contract that mints and owns an NFT upon deployment\n- The contract can have an owner, but the owner cannot `mint()` tokens — we might call this an *operator.* The operator can accept bids on the NFT, and can simultaneously close funding and withdraw the funds that were raised.\n- Contributors are able to send funds (e.g. ETH) to the contract in exchange for a proportional ownership stake in the future work.\n- Contributors are able to exit by using a method that burns their equity tokens and sends them their funds (initial contribution + profits)\n- The contract has a \"hard cap\", beyond which nobody else can join the crowdfund.\n    - This limits the original valuation for the NFT to something less than the expected profitability, limits exploitation of vulnerabilities, and also creates some scarcity around being part of the funding opportunity.\n    - The downside is that one person might just buy all of it, which is less fun.\n\n## Potential Downsides\n\n- It could have a vulnerability, and lose funds.\n\n## Implementation Details\n\nBasic sketch of the contract (please do not use in production, this is just a sketch and not intended to compile).\n\n```js\n// A completely untested sketch of a contract, written in a Notion doc.\ncontract Crowdfund is ERC20 {\n    using SafeMath for uint256;\n\n    // A list of possible states for crowd-funding.\n    enum Status {FUNDING, TRADING}\n    // The actual status of the crowd-fund, one of `Status`.\n    Status internal _status;\n\n    // Events representing crowdfunding life-cycle.\n    event FundingOpened(address media, address creator, uint256 creatorEquityPercent);\n    event Contribution(address contributor, uint256 amount);\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\n    event BidAccepted(uint256 amount);\n    event Withdrawal(address contributor, uint256 amount);\n\n    // The NFT's information.\n    address private _nftAddress;\n    uint256 _tokenId;\n\n\t\t// Creator's information.\n    // John is the artist and controls this contract.\n    address private _johns_address;\n    uint256 _johns_equity_percent;\n\n    // Cap it at 10 ETH.\n    uint256 private _funding_cap_eth = 10;\n\n    modifier onlyJohn() {\n        require(msg.sender == _johns_address);\n        _;\n    }\n\n    constructor(\n        address johns_address,\n        address mediaAddress,\n        memory nftData,\n        uint256 johns_equity_percent,\n        address WETH_\n    ) public ERC20(\"John's Crowdfund\", \"JOHN\") {\n        _nftAddress = mediaAddress;\n\n        // TODO: Mint an NFT with the owner being this contract, using\n\t\t\t\t// using nftData.\n\n        _johns_address = johns_address;\n        _johns_equity_percent = johns_equity_percent;\n\n        _status = Status.FUNDING;\n\n        emit FundingOpened(_nftAddress, _johns_address, _johns_equity_percent);\n    }\n\n    /*\n        Contributor Crowdfunding Methods\n     */\n\n    function contribute(uint256 amount) external {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n        \n        uint256 currentBalance = balanceOf(address(this));\n        require(\n            amount.add(currentBalance) < _funding_cap_eth.mul(1e18),\n            \"Total contributions would exceed funding cap\"\n        );\n\n        // Pull funds from the contributor to this contract.\n        require(\n            transferFrom(msg.sender, address(this), amount),\n            \"Contribution Failed\"\n        );\n\n        // Mint equity for the contributor.\n        _mint(msg.sender, amount);\n\n        emit Contribution(msg.sender, amount);\n    }\n\n    // The contributor can withdrawl at any time for their percent\n    // of the pool.\n    function withdraw(uint256 tokenAmount) external {\n        uint256 percentStake = tokenAmount.div(totalSupply());\n        uint256 withdrawAmount = percentStake.mul(balanceOf(address(this)));\n\n        _burn(msg.sender, tokenAmount);\n\n        require(transfer(msg.sender, withdrawAmount), \"Withdraw failed\");\n\n        emit Withdrawal(msg.sender, withdrawAmount);\n    }\n\n    /*\n        Operational Methods\n    */\n\n\t\tfunction closeFunding() external onlyJohn {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        // Transfer all funds to John.\n        uint256 amountRaised = balanceOf(address(this));\n        require(transfer(_johns_address, amountRaised), \"Withdraw failed\");\n\n        // Mint John some percent of the total supply.\n        // For example, if the total supply is 3 ETH, and\n        // John is set to get 5%, then he will get 0.15 ETH.\n        // 3 / 100 * 5 = 0.15.\n        uint256 tokensForJohn =\n            totalSupply().div(100).mul(_johns_equity_percent);\n        _mint(_johns_address, tokensForJohn);\n\n        // Close funding status, move to tradable.\n        _status = Status.TRADING;\n\n        emit FundingClosed(amountRaised, tokensForJohn);\n    }\n    \n    // As the operator, John is allowed to accept a bid for the\n    // NFT from the market. This should increase the money in the contract.\n    function acceptNFTBid(calldata bid) external onlyJohn {\n        require(_status == Status.TRADING, \"Status must be trading\");\n\n        // TODO: Accept a bid from an NFT market, thereby\n\t\t\t\t// receiving funds. Unwrap WETH if necessary.\n\n        emit BidAccepted(bid.amount);\n    }\n\n\t\t/*\n\t\t\tMiscellaneous operational functions, e.g. update NFT data.\n\t\t*/\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenURI(string calldata tokenURI) external onlyJohn {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenMetadataURI(string calldata metadataURI)\n        external\n        onlyJohn\n    {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        assert(msg.sender == WETH);\n    }\n}\n```", "timestamp": 1611173196, "digest": "llJ_AboiDJwB_ZAFz-CXU7fL2p8v5Wz6MjfluLafewQ", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "p_G9FVkw33PZIs4h4oasgMKLgzT5oEEoQoihyj4T1v0", "title": "Crowdfunding Writing with NFTs", "body": "Monetization of publicly accessible written content has never had a strong basis on the internet, since it suffers from the [public goods](https://en.wikipedia.org/wiki/Public_good) problem. As publishing has moved online, funding for high-quality, long-form writing has broken down.\n\nNFTs give us new tools to solve this problem — by a representing previously infinitely reproducible creative works as scarce, tradable digital assets. This means that artists can now *sell* a scarce digital asset representing an essay as a unique collectible or artwork, while the content itself remains open and freely accessible (a public good). Still, the problem remains for funding the time and work necessary for a creator to produce impactful writing. \n\nWe imagine a world where writers on Mirror can publish an intention to research and produce high-quality writing, and receive crowdsourced funding. In this model, the contributors who fund the project also receive a stake in the future financial upside produced by the work, captured by subsequent sales of the NFT. This improves considerably on existing crowdfunding platforms, such as Kickstarter.\n\nTo achieve these outcomes, the content must be tradable as a single artifact (an NFT), and the ownership of that artifact must be fractional — allowing multiple people to own a small stake. By using Ethereum as the economic infrastructure, we can allow tradable, fractional ownership of the NFT using ERC20 tokens.\n\nThe funders of the project should be able to trade their own currency (e.g. ETH or DAI) for an ownership stake before the project is completed. The creator should be able to withdraw pledged funds and use them to fund the production of the public good. The backers should be allowed to redeem the underlying funds (including profits) once the NFT is traded, proportional to the percent that they contributed to the fund. They can do this by provably burning their equity tokens in a single transaction that also redeems their funds. \n\nSince equity is represented as an ERC20, contributors might also trade their tokens on an exchange like Uniswap, instead of redeeming the underlying value — similar to trading options.\n\nIn the future, we imagine that the creator could be the operator of a DAO that produces many works, each of minted as an NFT, with ongoing revenue from trading accruing back to the DAO. Funders of the DAO can therefore expect profits beyond those coming from sales of the first NFT.\n\nThis could signal the beginning of a movement towards journalist and artist DAOs.\n\nIn this post, we include our technical considerations for this project and a sketch of the contract that might serve this purpose. We welcome any and all feedback on our ideas. We will target a demo of the working functionality on Friday during a live-stream.\n\n![](https://images.mirror-media.xyz/publication-images/1cddf105-e9c1-4a79-b72a-9daf4be83712.jpeg?height=1504&width=1348)\n\n## Problems We're Solving\n\n- Writers want funding for a long-form piece of content before writing it\n- Contributors want to fund their favorite writers, and receive some return on their investment\n- Contributors want to be recognized as patrons of public goods\n- Speculators want to invest in NFTs, including those that represent *written* works\n- Nobody wants to pay excessive gas costs that make it unprofitable to solve these problems\n\n## What Success Looks Like\n\n- Contributors can exchange currency (e.g. ETH) for some ownership stake in a future work\n- The Creator can withdraw the funds that are raised, and thereby close the funding session\n- The work is represented by a tradable NFT\n- The Creator can update the NFT's metadata once the work is finished\n- The Creator can trade that NFT for a profit\n- Contributors can trade their ownership stake on Uniswap\n- Contributors can divest their stake for accumulated revenue\n- The Creator can receive an ownership stake once the funding is closed, entitling them to a share of the future profits as well\n\n## Out of Scope\n\n- Bringing this into the scope of the *Publication Contract*, and thereby blocking experimentation on that work-stream.\n\n# Engineering RFC\n\n## Implementation Summary\n\n- There is an ERC20-compatible contract that mints and owns an NFT upon deployment\n- The contract can have an owner, but the owner cannot `mint()` tokens — we might call this an *operator.* The operator can accept bids on the NFT, and can simultaneously close funding and withdraw the funds that were raised.\n- Contributors are able to send funds (e.g. ETH) to the contract in exchange for a proportional ownership stake in the future work.\n- Contributors are able to exit by using a method that burns their equity tokens and sends them their funds (initial contribution + profits)\n- The contract has a \"hard cap\", beyond which nobody else can join the crowdfund.\n    - This limits the original valuation for the NFT to something less than the expected profitability, limits exploitation of vulnerabilities, and also creates some scarcity around being part of the funding opportunity.\n    - The downside is that one person might just buy all of it, which is less fun.\n\n## Potential Downsides\n\n- It could have a vulnerability, and lose funds.\n\n## Implementation Details\n\nBasic sketch of the contract (please do not use in production, this is just a sketch and not intended to compile).\n\n```js\n// A completely untested sketch of a contract, written in a Notion doc.\ncontract Crowdfund is ERC20 {\n    using SafeMath for uint256;\n\n    // A list of possible states for crowd-funding.\n    enum Status {FUNDING, TRADING}\n    // The actual status of the crowd-fund, one of `Status`.\n    Status internal _status;\n\n    // Events representing crowdfunding life-cycle.\n    event FundingOpened(address media, address creator, uint256 creatorEquityPercent);\n    event Contribution(address contributor, uint256 amount);\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\n    event BidAccepted(uint256 amount);\n    event Withdrawal(address contributor, uint256 amount);\n\n    // The NFT's information.\n    address private _nftAddress;\n    uint256 _tokenId;\n\n\t\t// Creator's information.\n    // John is the artist and controls this contract.\n    address private _johns_address;\n    uint256 _johns_equity_percent;\n\n    // Cap it at 10 ETH.\n    uint256 private _funding_cap_eth = 10;\n\n    modifier onlyJohn() {\n        require(msg.sender == _johns_address);\n        _;\n    }\n\n    constructor(\n        address johns_address,\n        address mediaAddress,\n        memory nftData,\n        uint256 johns_equity_percent,\n        address WETH_\n    ) public ERC20(\"John's Crowdfund\", \"JOHN\") {\n        _nftAddress = mediaAddress;\n\n        // TODO: Mint an NFT with the owner being this contract, using\n\t\t\t\t// using nftData.\n\n        _johns_address = johns_address;\n        _johns_equity_percent = johns_equity_percent;\n\n        _status = Status.FUNDING;\n\n        emit FundingOpened(_nftAddress, _johns_address, _johns_equity_percent);\n    }\n\n    /*\n        Contributor Crowdfunding Methods\n     */\n\n    function contribute(uint256 amount) external {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n        \n        uint256 currentBalance = balanceOf(address(this));\n        require(\n            amount.add(currentBalance) < _funding_cap_eth.mul(1e18),\n            \"Total contributions would exceed funding cap\"\n        );\n\n        // Pull funds from the contributor to this contract.\n        require(\n            transferFrom(msg.sender, address(this), amount),\n            \"Contribution Failed\"\n        );\n\n        // Mint equity for the contributor.\n        _mint(msg.sender, amount);\n\n        emit Contribution(msg.sender, amount);\n    }\n\n    // The contributor can withdrawl at any time for their percent\n    // of the pool.\n    function withdraw(uint256 tokenAmount) external {\n        uint256 percentStake = tokenAmount.div(totalSupply());\n        uint256 withdrawAmount = percentStake.mul(balanceOf(address(this)));\n\n        _burn(msg.sender, tokenAmount);\n\n        require(transfer(msg.sender, withdrawAmount), \"Withdraw failed\");\n\n        emit Withdrawal(msg.sender, withdrawAmount);\n    }\n\n    /*\n        Operational Methods\n    */\n\n\t\tfunction closeFunding() external onlyJohn {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        // Transfer all funds to John.\n        uint256 amountRaised = balanceOf(address(this));\n        require(transfer(_johns_address, amountRaised), \"Withdraw failed\");\n\n        // Mint John some percent of the total supply.\n        // For example, if the total supply is 3 ETH, and\n        // John is set to get 5%, then he will get 0.15 ETH.\n        // 3 / 100 * 5 = 0.15.\n        uint256 tokensForJohn =\n            totalSupply().div(100).mul(_johns_equity_percent);\n        _mint(_johns_address, tokensForJohn);\n\n        // Close funding status, move to tradable.\n        _status = Status.TRADING;\n\n        emit FundingClosed(amountRaised, tokensForJohn);\n    }\n    \n    // As the operator, John is allowed to accept a bid for the\n    // NFT from the market. This should increase the money in the contract.\n    function acceptNFTBid(calldata bid) external onlyJohn {\n        require(_status == Status.TRADING, \"Status must be trading\");\n\n        // TODO: Accept a bid from an NFT market, thereby\n\t\t\t\t// receiving funds. Unwrap WETH if necessary.\n\n        emit BidAccepted(bid.amount);\n    }\n\n\t\t/*\n\t\t\tMiscellaneous operational functions, e.g. update NFT data.\n\t\t*/\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenURI(string calldata tokenURI) external onlyJohn {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenMetadataURI(string calldata metadataURI)\n        external\n        onlyJohn\n    {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        assert(msg.sender == WETH);\n    }\n}\n```", "timestamp": 1611173120, "digest": "llJ_AboiDJwB_ZAFz-CXU7fL2p8v5Wz6MjfluLafewQ", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "hYfYnzjBhFHV0nhc8T2VEBGfGiKI7I3ErQWwS9pLltk", "title": "Crowdfunding Writing with NFTs", "body": "Monetization of publicly accessible written content has never had a strong basis on the internet, since it suffers from the [public goods](https://en.wikipedia.org/wiki/Public_good) problem. As publishing has moved online, funding for high-quality, long-form writing has broken down.\n\nNFTs give us new tools to solve this problem — by a representing previously infinitely reproducible creative works as scarce, tradable digital assets. This means that artists can now *sell* a scarce digital asset representing an essay as a unique collectible or artwork, while the content itself remains open and freely accessible (a public good). Still, the problem remains for funding the time and work necessary for a creator to produce impactful writing. \n\nWe imagine a world where writers on Mirror can publish an intention to research and produce high-quality writing, and receive crowdsourced funding. In this model, the contributors who fund the project also receive a stake in the future financial upside produced by the work, captured by subsequent sales of the NFT. This improves considerably on existing crowdfunding platforms, such as Kickstarter.\n\nTo achieve these outcomes, the content must be tradable as a single artifact (an NFT), and the ownership of that artifact must be fractional — allowing multiple people to own a small stake. By using Ethereum as the economic infrastructure, we can allow tradable, fractional ownership of the NFT using ERC20 tokens.\n\nThe funders of the project should be able to trade their own currency (e.g. ETH or DAI) for an ownership stake before the project is completed. The creator should be able to withdraw pledged funds and use them to fund the production of the public good. The backers should be allowed to redeem the underlying funds (including profits) once the NFT is traded, proportional to the percent that they contributed to the fund. They can do this by provably burning their equity tokens in a single transaction that also redeems their funds. \n\nSince equity is represented as an ERC20, contributors might also trade their tokens on an exchange like Uniswap, instead of redeeming the underlying value — similar to trading options.\n\nIn the future, we imagine that the creator could be the operator of a DAO that produces many works, each of minted as an NFT, with ongoing revenue from trading accruing back to the DAO. Funders of the DAO can therefore expect profits beyond those coming from sales of the first NFT.\n\nThis could signal the beginning of a movement towards journalist and artist DAOs.\n\nIn this post, we include our technical considerations for this project and a sketch of the contract that might serve this purpose. We welcome any and all feedback on our ideas. We will target a demo of the working functionality on Friday during a live-stream.\n\n![](https://images.mirror-media.xyz/publication-images/1cddf105-e9c1-4a79-b72a-9daf4be83712.jpeg?height=1504&width=1348)\n\n## Problems We're Solving\n\n- Writers want funding for a long-form piece of content before writing it\n- Contributors want to fund their favorite writers, and receive some return on their investment\n- Contributors want to be recognized as patrons of public goods\n- Speculators want to invest in NFTs, including those that represent *written* works\n- Nobody wants to pay excessive gas costs that make it unprofitable to solve these problems\n\n## What Success Looks Like\n\n- Contributors can exchange currency (e.g. ETH) for some ownership stake in a future work\n- The Creator can withdraw the funds that are raised, and thereby close the funding session\n- The work is represented by a tradable NFT\n- The Creator can update the NFT's metadata once the work is finished\n- The Creator can trade that NFT for a profit\n- Contributors can trade their ownership stake on Uniswap\n- Contributors can divest their stake for accumulated revenue\n- The Creator can receive an ownership stake once the funding is closed, entitling them to a share of the future profits as well\n\n## Out of Scope\n\n- Bringing this into the scope of the *Publication Contract*, and thereby blocking experimentation on that work-stream.\n\n## Implementation Summary\n\n- There is an ERC20-compatible contract that mints and owns an NFT upon deployment\n- The contract can have an owner, but the owner cannot `mint()` tokens — we might call this an *operator.* The operator can accept bids on the NFT, and can simultaneously close funding and withdraw the funds that were raised.\n- Contributors are able to send funds (e.g. ETH) to the contract in exchange for a proportional ownership stake in the future work.\n- Contributors are able to exit by using a method that burns their equity tokens and sends them their funds (initial contribution + profits)\n- The contract has a \"hard cap\", beyond which nobody else can join the crowdfund.\n    - This limits the original valuation for the NFT to something less than the expected profitability, limits exploitation of vulnerabilities, and also creates some scarcity around being part of the funding opportunity.\n    - The downside is that one person might just buy all of it, which is less fun.\n\n## Potential Downsides\n\n- It could have a vulnerability, and lose funds.\n\n## Implementation Details\n\nBasic sketch of the contract (please do not use in production, this is just a sketch and not intended to compile).\n\n```js\n// A completely untested sketch of a contract, written in a Notion doc.\ncontract Crowdfund is ERC20 {\n    using SafeMath for uint256;\n\n    // A list of possible states for crowd-funding.\n    enum Status {FUNDING, TRADING}\n    // The actual status of the crowd-fund, one of `Status`.\n    Status internal _status;\n\n    // Events representing crowdfunding life-cycle.\n    event FundingOpened(\n        address media,\n        address creator,\n        uint256 creatorEquityPercent\n    );\n    event Contribution(address contributor, uint256 amount);\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\n    event BidAccepted(uint256 amount);\n    event Withdrawal(address contributor, uint256 amount);\n\n    // The NFT's information.\n    address private _nftAddress;\n    uint256 _tokenId;\n\n    // Creator's information.\n    // John is the artist and controls this contract.\n    address private _johns_address;\n    uint256 _johns_equity_percent;\n\n    // Cap it at 10 ETH.\n    uint256 private _funding_cap_eth = 10;\n\n    modifier onlyJohn() {\n        require(msg.sender == _johns_address);\n        _;\n    }\n\n    constructor(\n        address johns_address,\n        address mediaAddress,\n        Data memory nftData,\n        uint256 johns_equity_percent,\n        address WETH_\n    ) public ERC20(\"John's Crowdfund\", \"JOHN\") {\n        _nftAddress = mediaAddress;\n\n        // TODO: Mint an NFT with the owner being this contract, using\n        // using nftData.\n\n        _johns_address = johns_address;\n        _johns_equity_percent = johns_equity_percent;\n\n        _status = Status.FUNDING;\n\n        emit FundingOpened(_nftAddress, _johns_address, _johns_equity_percent);\n    }\n\n    /*\n        Contributor Crowdfunding Methods\n     */\n\n    function contribute(uint256 amount) external {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        uint256 currentBalance = balanceOf(address(this));\n        require(\n            amount.add(currentBalance) < _funding_cap_eth.mul(1e18),\n            \"Total contributions would exceed funding cap\"\n        );\n\n        // Pull funds from the contributor to this contract.\n        require(\n            transferFrom(msg.sender, address(this), amount),\n            \"Contribution Failed\"\n        );\n\n        // Mint equity for the contributor.\n        _mint(msg.sender, amount);\n\n        emit Contribution(msg.sender, amount);\n    }\n\n    // The contributor can withdrawl at any time for their percent\n    // of the pool.\n    function withdraw(uint256 tokenAmount) external {\n        uint256 percentStake = tokenAmount.div(totalSupply());\n        uint256 withdrawAmount = percentStake.mul(balanceOf(address(this)));\n\n        _burn(msg.sender, tokenAmount);\n\n        require(transfer(msg.sender, withdrawAmount), \"Withdraw failed\");\n\n        emit Withdrawal(msg.sender, withdrawAmount);\n    }\n\n    /*\n        Operational Methods\n    */\n\n    function closeFunding() external onlyJohn {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        // Transfer all funds to John.\n        uint256 amountRaised = balanceOf(address(this));\n        require(transfer(_johns_address, amountRaised), \"Withdraw failed\");\n\n        // Mint John some percent of the total supply.\n        // For example, if the total supply is 3 ETH, and\n        // John is set to get 5%, then he will get 0.15 ETH.\n        // 3 / 100 * 5 = 0.15.\n        uint256 tokensForJohn =\n            totalSupply().div(100).mul(_johns_equity_percent);\n        _mint(_johns_address, tokensForJohn);\n\n        // Close funding status, move to tradable.\n        _status = Status.TRADING;\n\n        emit FundingClosed(amountRaised, tokensForJohn);\n    }\n\n    // As the operator, John is allowed to accept a bid for the\n    // NFT from the market. This should increase the money in the contract.\n    function acceptNFTBid(Bid calldata bid) external onlyJohn {\n        require(_status == Status.TRADING, \"Status must be trading\");\n\n        // TODO: Accept a bid from an NFT market, thereby\n        // receiving funds. Unwrap WETH if necessary.\n\n        emit BidAccepted(bid.amount);\n    }\n\n    /*\n        Miscellaneous operational functions, e.g. update NFT data.\n    */\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenURI(string calldata tokenURI) external onlyJohn {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenMetadataURI(string calldata metadataURI)\n        external\n        onlyJohn\n    {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        assert(msg.sender == WETH);\n    }\n}\n```", "timestamp": 1611173980, "digest": "llJ_AboiDJwB_ZAFz-CXU7fL2p8v5Wz6MjfluLafewQ", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "r9hwBX0LRZaywz2yKSwMgtqerZztcKo5GpenO-Lu2Jw", "title": "Live Video, Censorship Resistance, and Responsibility", "body": "\nOne of the core value propositions of decentralized technologies such as Bitcoin and Ethereum is often stated as censorship resistance. Some have gone so far as to say that it’s the only value proposition that matters and determines whether a decentralized system can be advantageous relative to a centralized one, because otherwise the extra costs and complexity of using such systems wouldn’t be worth it relative to efficient centralized alternatives. With the current events unfolding in the world, and the centralized platforms responses to these events being to ban users and limit what may be communicated, many have looked to the set of decentralized technologies, collectively known as web3, to enable trustless platforms which make it impossible for this type of selective censorship to occur. Of course the chorus of financially motivated stakeholders in the projects see this as an opportunity for growth, attention, and “web3’s moment”, however I’d caution many parties here — the project builders themselves, their communities, their financial backers, and their users to tread cautiously. This is a responsibility that should be handled with care.\n\nI work on a decentralized video infrastructure project called [Livepeer](http://livepeer.org/), where our mission is to build the world’s open video infrastructure. In the early days of the project I spent a lot of time talking about the positive benefits of an open video platform, such as enabling developers to build platforms that protect live journalism, freedom of speech, and community governed content policies. I still very much think these are great ideals to aspire to. But, many users unable to recognize the difference between an infrastructure platform and a consumer application, mistakenly believed that Livepeer was building something that looked like a censorship resistant Youtube — where individual streamers could show up and begin broadcasting their content.\n\nThe dark side of censorship resistance began to expose itself, as many of those unhappy with the existing centralized streaming platforms, were looking to use an alternative for a purpose that may look familiar to challenges that our society is asking the large social platforms like Facebook, Twitter, and Twitch to police today — the spread of misinformation, coordination of violence, even copyright infringement which seems quaint by comparison. I spent time with 3rd party rights protection groups like [Thorn.org](http://thorn.org/), which work tirelessly to protect children from abuse that occurs to them via the internet. These things aren’t freedom of speech or censorship issues, they are actually legal violations, life-altering level harmful, and potentially risks to society.\n\nWhile any large platform that coordinates large groups of people across a wide cross-slice of humanity ends up having to deal with these challenges, [it is especially exacerbated in the live video streaming world](https://www.nytimes.com/2021/01/08/technology/dlive-capitol-mob.html). Content in a live stream is typically consumed within seconds of its creation, leaving things like community moderation, potentially insufficient to provide the protections needed to prevent the harm that can come.\n\nStill, despite awareness of the risks posed by censorship resistance and the harm that can come, do we want to live in a world where all distribution is controlled by a handful of Silicon Valley insiders? A world where, with the snap of a finger, any idea that doesn’t align with a single ideology, or a single country’s laws, can be eliminated from public view? Unlikely. So what is the middle ground that we should strive for? And how does an open video infrastructure like Livepeer view what it is doing, in light of the many of the above challenges and potential? Like any complex and nuanced issue, the answer isn’t straightforward, but my view of this is that one must look closely at the shifting responsibilities across the layers of the stack, and then apply an appropriate level of control and optionality based upon where one is building.\n\n![Moderation responsibilities across the stack](https://miro.medium.com/max/1114/1\\*ALnM3p6IeMLnW9-4JQTP6Q.png)\n\nThe level of responsibility, control, and moderation that one has for harmful use that can result, starts very low at the bottom of this stack, but must increase as one moves up the stack. While protocol definitions should be neutral, open, and un-opinionated at the bottom, the distribution layers for content at the top bear massive responsibility to ensure that limited damage can come from content going from 0 to 2 billion eyeballs in a matter of seconds as enabled by the power-law scale of social platforms today.\n\nLivepeer builds primarily at the bottom three layers of this stack, so let’s take a bit of a closer look at each layer, with some commentary on how I think about Livepeer’s role and responsibilities at each.\n\n### Protocol Layer\n\nAt the base layer, protocols should be neutral, open, and un-opinionated. Protocols like TCP/IP, Bitcoin, or HLS are tremendously powerful building block which can enable countless upstream use cases, and even though one could connect the dots to both beneficial and harmful applications in the future, the protocol designers bear little to no responsibility for what people choose to do or not do with it at much higher layers. It would be foolhardy and overcomplicated to try to embed controls at a layer responsible for moving packets of data across routers, establishing a shared ledger of account balances for an asset, or reliable delivery of live video.\n\nThe Livepeer protocol definition specifies a marketplace that compute resources can advertise their available services, be compensated for work by the users of those services, and ensure that the services were performed correctly. Initially, transcoding and other forms of compute for live video are the primary services. Simple and straightforward, there is no emphasis on controls for censorship or moderation at this layer.\n\n### Software Layer\n\nThe open source software that implements these protocols, bears just slightly more responsibility. Here, we go from protocol definition, to implementation, and often complimentary features and enhancements targeted at certain user groups. Flexible by nature, it is hard to anticipate its use, and responsible builders will enable options and controls to give users the abilities to make their own decisions about the level of moderation they’d like to apply to content.\n\nIn the Livepeer node implementation, you still see generic and open feature sets to enable video streaming broadly. You don’t see features targeted towards users building hate-speech applications, or copyright violation applications. But you do see the beginnings of controls that can ensure that no one running the software will have to participate in hate speech or copyright violations if they choose note to — for example the ability for the software to let the user limit its use to encode video only on behalf of known sources of video.\n\n### Infrastructure Layer\n\nUp at the infrastructure layer you have entities running the software, at scale, to be the reliable building blocks for platforms. Here it becomes the infrastructure operators responsibilities to USE the above controls from the software layer, to create policies that align with their ideologies and intentions. Yet still, infrastructure is meant to be open, cost effective, efficient, and generic for a variety of use cases.\n\nIn a decentralized network like Livepeer, the community has the opportunity to think about network-wide assistance that can be given to individual node operators, such as the ability to tap into known 3rd party moderation lists, to prevent their own resources from being used for purposes that they don’t want to be part of supporting. Smart video capabilities like scene classification can be used to allow nodes to automatically reject working on certain types of content. Running a Livepeer node does not mean consenting to contribute one’s resources for harmful purposes.\n\n### Application Layer\n\nAs you push above the infrastructure layer to the application layer, the level of responsibility increases exponentially. Applications serve as the point of creation and access for content. They are built for specific audiences, communities, or content types. They have their own terms of use policies, and corporate or community enforcement of rules. And these rules matter and have real consequences. If an application level policy is censorship resistant live video, then prepare for the challenges that come with the dark side.\n\nAt Livepeer we stayed below this layer for the first 2.5 years of the project, building only up to infrastructure. And as we did push up to the application layer in the past year, we avoided being a content application, and instead launched a [SaaS streaming service for developers to use to build their own apps](http://livepeer.com/) — essentially a gateway to the infrastructure. While the infrastructure, software, and protocol are all open as described above, at the application is the first layer where we put in a firm stance on moderation and censorship resistance. The centralized livepeer.com API has a terms of use policy which prevents use cases that are illegal, hateful, or inciting violence. That is our decision, but it’s also the layer at which the stack stops becoming open. Someone else could build an open and decentralized application at this layer that makes different choices, and still leverage the infrastructure, software, and protocol below — though potentially without access to the nodes that choose not to support it.\n\n### Distribution Layer\n\nFinally, at the top of the stack you have the distribution layers, which despite not being directly associated with the applications, they profit from the apps, and they bear a societal level of responsibility for their policies on moderation and censorship resistance. App stores and large social platforms that virally spread content created by applications, and their attention economy supported business models, which have taken advantage of network effects to enable reaching full-societal-scale reach, have no choice but to recognize the level of responsibility that they have in making a best effort to ensure that tremendous harm doesn’t come from the content that they are amplifying. It doesn’t matter if Facebook runs on in house infrastructure, EC2, or Livepeer — they have a higher level of responsibility to make sure that violence-insighting content doesn’t reach two billion users within minutes of its creation. Apple has a responsibility to make sure that applications that are abusive of minors aren’t accessible to two billion people through its app store.\n\n— —\n\nAs seen from above, the infrastructure layer appears most grey, and it’s also where the majority of users of Livepeer operate. There are tricky problems here, as I believe an open compute infrastructure, enables tremendous good and opportunity for the world. It can be the building block for ownership economy applications that better align incentives and economic relationships between creators, consumers, and platforms, than the attention-economy models that have lead us to where we are today on the large social platforms.\n\nBut at the same time, the Livepeer community needs to have a high level of awareness and responsibility to ensure that what we build can contribute to positive societal outcomes. As an open network, this is community determined, rather than centrally determined, and you can imagine why the interpretation may be different across ideologies or jurisdictions. As outlined above though, the approach has been to plan and account for the configuration touchpoints, governance mechanisms, and tools to let the network operators decide what they are contributing their compute resources to. On the tool front this includes things like configurable controls for which video sources one is working with, and even nascent machine learning research on scene classification that can identify whether content is violent, explicit, or likely to be copyrighted.\n\nRegardless of the best efforts at the infrastructure or software layer however, applications and distribution channels will need to account for their own community and content moderation from day one, lest they run into inevitable challenges as they scale and things get messy. While I have, and continue to talk about the benefits of building applications that empower the positive types of free and open communication, I do not believe that the policy of complete censorship resistance of live video, with wide distribution leads to a lighter place than the darkness enabled by abuse of such systems. I hope that those building across the spectrum from protocol through to distribution, join me in taking accountability and responsibility seriously to ensure that we all build things that enable the positive future we want to see exist.\n", "timestamp": 1611176926, "digest": "jPgJI2rj_goV-nhTz2FvSTCjputvjDOnyCd7uzmsdyo", "contributor": "0xa99438A1A6de4943756c9eF05Be41288d2EEC6CA"}
{"id": "iFIvQf-5coGofjsRMinlm48RQp2eOuigQ6Xt2VRkXAY", "title": "Crowdfunding Writing with NFTs", "body": "Monetization of publicly accessible written content has never had a strong basis on the internet, since it suffers from the [public goods](https://en.wikipedia.org/wiki/Public_good) problem. As publishing has moved online, funding for high-quality, long-form writing has broken down.\n\nNFTs give us new tools to solve this problem — by a representing previously infinitely reproducible creative works as scarce, tradable digital assets. This means that artists can now *sell* a scarce digital asset representing an essay as a unique collectible or artwork, while the content itself remains open and freely accessible (a public good). Still, the problem remains for funding the time and work necessary for a creator to produce impactful writing. \n\nWe imagine a world where writers on Mirror can publish an intention to research and produce high-quality writing, and receive crowdsourced funding. In this model, the contributors who fund the project also receive a stake in the future financial upside produced by the work, captured by subsequent sales of the NFT. This improves considerably on existing crowdfunding platforms, such as Kickstarter.\n\nTo achieve these outcomes, the content must be tradable as a single artifact (an NFT), and the ownership of that artifact must be fractional — allowing multiple people to own a small stake. By using Ethereum as the economic infrastructure, we can allow tradable, fractional ownership of the NFT using ERC20 tokens.\n\nThe funders of the project should be able to trade their own currency (e.g. ETH or DAI) for an ownership stake before the project is completed. The creator should be able to withdraw pledged funds and use them to fund the production of the public good. The backers should be allowed to redeem the underlying funds (including profits) once the NFT is traded, proportional to the percent that they contributed to the fund. They can do this by provably burning their equity tokens in a single transaction that also redeems their funds. \n\nSince equity is represented as an ERC20, contributors might also trade their tokens on an exchange like Uniswap, instead of redeeming the underlying value — similar to trading options.\n\nIn the future, we imagine that the creator could be the operator of a DAO that produces many works, each of minted as an NFT, with ongoing revenue from trading accruing back to the DAO. Funders of the DAO can therefore expect profits beyond those coming from sales of the first NFT.\n\nThis could signal the beginning of a movement towards journalist and artist DAOs.\n\nIn this post, we include our technical considerations for this project and a sketch of the contract that might serve this purpose. We welcome any and all feedback on our ideas. We will target a demo of the working functionality on Friday during a live-stream.\n\n![](https://images.mirror-media.xyz/publication-images/1cddf105-e9c1-4a79-b72a-9daf4be83712.jpeg?height=1504&width=1348)\n\n## Problems We're Solving\n\n- Writers want funding for a long-form piece of content before writing it\n- Contributors want to fund their favorite writers, and receive some return on their investment\n- Contributors want to be recognized as patrons of public goods\n- Speculators want to invest in NFTs, including those that represent *written* works\n- Nobody wants to pay excessive gas costs that make it unprofitable to solve these problems\n\n## What Success Looks Like\n\n- Contributors can exchange currency (e.g. ETH) for some ownership stake in a future work\n- The Creator can withdraw the funds that are raised, and thereby close the funding session\n- The work is represented by a tradable NFT\n- The Creator can update the NFT's metadata once the work is finished\n- The Creator can trade that NFT for a profit\n- Contributors can trade their ownership stake on Uniswap\n- Contributors can divest their stake for accumulated revenue\n- The Creator can receive an ownership stake once the funding is closed, entitling them to a share of the future profits as well\n\n## Out of Scope\n\n- Bringing this into the scope of the *Publication Contract*, and thereby blocking experimentation on that work-stream.\n\n## Implementation Summary\n\n- There is an ERC20-compatible contract that mints and owns an NFT upon deployment\n- The contract can have an owner, but the owner cannot `mint()` tokens — we might call this an *operator.* The operator can accept bids on the NFT, and can simultaneously close funding and withdraw the funds that were raised.\n- Contributors are able to send funds (e.g. ETH) to the contract in exchange for a proportional ownership stake in the future work.\n- Contributors are able to exit by using a method that burns their equity tokens and sends them their funds (initial contribution + profits)\n- The contract has a \"hard cap\", beyond which nobody else can join the crowdfund.\n    - This limits the original valuation for the NFT to something less than the expected profitability, limits exploitation of vulnerabilities, and also creates some scarcity around being part of the funding opportunity.\n    - The downside is that one person might just buy all of it, which is less fun.\n\n## Potential Downsides\n\n- It could have a vulnerability, and lose funds.\n\n## Implementation Details\n\nBasic sketch of the contract (please do not use in production, this is just a sketch and not intended to compile).\n\n```js\n// A completely untested sketch of a contract, written in a Notion doc.\ncontract Crowdfund is ERC20 {\n    using SafeMath for uint256;\n\n    // A list of possible states for crowd-funding.\n    enum Status {FUNDING, TRADING}\n    // The actual status of the crowd-fund, one of `Status`.\n    Status internal _status;\n\n    // Events representing crowdfunding life-cycle.\n    event FundingOpened(\n        address media,\n        address creator,\n        uint256 creatorEquityPercent\n    );\n    event Contribution(address contributor, uint256 amount);\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\n    event BidAccepted(uint256 amount);\n    event Withdrawal(address contributor, uint256 amount);\n\n    // The NFT's information.\n    address private _nftAddress;\n    uint256 _tokenId;\n\n    // Creator's information.\n    // John is the artist and controls this contract.\n    address private _johns_address;\n    uint256 _johns_equity_percent;\n\n    // Cap it at 10 ETH.\n    uint256 private _funding_cap_eth = 10;\n\n    modifier onlyJohn() {\n        require(msg.sender == _johns_address);\n        _;\n    }\n\n    constructor(\n        address johns_address,\n        address mediaAddress,\n        Data memory nftData,\n        uint256 johns_equity_percent,\n        address WETH_\n    ) public ERC20(\"John's Crowdfund\", \"JOHN\") {\n        _nftAddress = mediaAddress;\n\n        // TODO: Mint an NFT with the owner being this contract, using\n        // using nftData.\n\n        _johns_address = johns_address;\n        _johns_equity_percent = johns_equity_percent;\n\n        _status = Status.FUNDING;\n\n        emit FundingOpened(_nftAddress, _johns_address, _johns_equity_percent);\n    }\n\n    /*\n        Contributor Crowdfunding Methods\n     */\n\n    function contribute(uint256 amount) external {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        uint256 currentBalance = balanceOf(address(this));\n        require(\n            amount.add(currentBalance) < _funding_cap_eth.mul(1e18),\n            \"Total contributions would exceed funding cap\"\n        );\n\n        // Pull funds from the contributor to this contract.\n        require(\n            transferFrom(msg.sender, address(this), amount),\n            \"Contribution Failed\"\n        );\n\n        // Mint equity for the contributor.\n        _mint(msg.sender, amount);\n\n        emit Contribution(msg.sender, amount);\n    }\n\n    // The contributor can withdrawl at any time for their percent\n    // of the pool.\n    function withdraw(uint256 tokenAmount) external {\n        uint256 percentStake = tokenAmount.div(totalSupply());\n        uint256 withdrawAmount = percentStake.mul(balanceOf(address(this)));\n\n        _burn(msg.sender, tokenAmount);\n\n        require(transfer(msg.sender, withdrawAmount), \"Withdraw failed\");\n\n        emit Withdrawal(msg.sender, withdrawAmount);\n    }\n\n    /*\n        Operational Methods\n    */\n\n    function closeFunding() external onlyJohn {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        // Transfer all funds to John.\n        uint256 amountRaised = balanceOf(address(this));\n        require(transfer(_johns_address, amountRaised), \"Withdraw failed\");\n\n        // Mint John some percent of the total supply.\n        // For example, if the total supply is 3 ETH, and\n        // John is set to get 5%, then he will get 0.15 ETH.\n        // 3 / 100 * 5 = 0.15.\n        uint256 tokensForJohn =\n            totalSupply().div(100).mul(_johns_equity_percent);\n        _mint(_johns_address, tokensForJohn);\n\n        // Close funding status, move to tradable.\n        _status = Status.TRADING;\n\n        emit FundingClosed(amountRaised, tokensForJohn);\n    }\n\n    // As the operator, John is allowed to accept a bid for the\n    // NFT from the market. This should increase the money in the contract.\n    function acceptNFTBid(Bid calldata bid) external onlyJohn {\n        require(_status == Status.TRADING, \"Status must be trading\");\n\n        // TODO: Accept a bid from an NFT market, thereby\n        // receiving funds. Unwrap WETH if necessary.\n\n        emit BidAccepted(bid.amount);\n    }\n\n    /*\n        Miscellaneous operational functions, e.g. update NFT data.\n    */\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenURI(string calldata tokenURI) external onlyJohn {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenMetadataURI(string calldata metadataURI)\n        external\n        onlyJohn\n    {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        assert(msg.sender == WETH);\n    }\n}\n```\n\nPlease comment with feedback on this thread:\n\n[](https://twitter.com/viamirror/status/1351989735191937027)", "timestamp": 1611179700, "digest": "llJ_AboiDJwB_ZAFz-CXU7fL2p8v5Wz6MjfluLafewQ", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "Vu2PBPKj32HIKBVikL6d_fCTPH6vZv0TzzIJkeJp7Dg", "title": "Crowdfunding Writing with NFTs", "body": "Monetization of publicly accessible written content has never had a strong basis on the internet, since it suffers from the [public goods](https://en.wikipedia.org/wiki/Public_good) problem. As publishing has moved online, funding for high-quality, long-form writing has broken down.\n\nNFTs give us new tools to solve this problem — by representing previously infinitely-reproducible creative works as scarce, tradable digital assets. This means that artists can now *sell* a scarce digital asset representing an essay as a unique collectible or artwork, while the content itself remains open and freely accessible (a public good). Still, the problem remains for funding the time and work necessary for a creator to produce impactful writing. \n\nWe imagine a world where writers on Mirror can publish an intention to research and produce high-quality writing, and receive crowdsourced funding. In this model, the contributors who fund the project also receive a stake in the future financial upside produced by the work, captured by subsequent sales of the NFT. This improves considerably on existing crowdfunding platforms, such as Kickstarter.\n\nTo achieve these outcomes, the content must be tradable as a single artifact (an NFT), and the ownership of that artifact must be fractional — allowing multiple people to own a small stake. By using Ethereum as the economic infrastructure, we can allow tradable, fractional ownership of the NFT using ERC20 tokens.\n\nThe funders of the project should be able to trade their own currency (e.g. ETH or DAI) for an ownership stake before the project is completed. The creator should be able to withdraw pledged funds and use them to fund the production of the public good. The backers should be allowed to redeem the underlying funds (including profits) once the NFT is traded, proportional to the percent that they contributed to the fund. They can do this by provably burning their equity tokens in a single transaction that also redeems their funds. \n\nSince equity is represented as an ERC20, contributors might also trade their tokens on an exchange like Uniswap, instead of redeeming the underlying value — similar to trading options.\n\nIn the future, we imagine that the creator could be the operator of a DAO that produces many works, each of minted as an NFT, with ongoing revenue from trading accruing back to the DAO. Funders of the DAO can therefore expect profits beyond those coming from sales of the first NFT.\n\nThis could signal the beginning of a movement towards journalist and artist DAOs.\n\nIn this post, we include our technical considerations for this project and a sketch of the contract that might serve this purpose. We welcome any and all feedback on our ideas. We will target a demo of the working functionality on Friday during a live-stream.\n\n![](https://images.mirror-media.xyz/publication-images/1cddf105-e9c1-4a79-b72a-9daf4be83712.jpeg?height=1504&width=1348)\n\n## Problems We're Solving\n\n- Writers want funding for a long-form piece of content before writing it\n- Contributors want to fund their favorite writers, and receive some return on their investment\n- Contributors want to be recognized as patrons of public goods\n- Speculators want to invest in NFTs, including those that represent *written* works\n- Nobody wants to pay excessive gas costs that make it unprofitable to solve these problems\n\n## What Success Looks Like\n\n- Contributors can exchange currency (e.g. ETH) for some ownership stake in a future work\n- The Creator can withdraw the funds that are raised, and thereby close the funding session\n- The work is represented by a tradable NFT\n- The Creator can update the NFT's metadata once the work is finished\n- The Creator can trade that NFT for a profit\n- Contributors can trade their ownership stake on Uniswap\n- Contributors can divest their stake for accumulated revenue\n- The Creator can receive an ownership stake once the funding is closed, entitling them to a share of the future profits as well\n\n## Out of Scope\n\n- Bringing this into the scope of the *Publication Contract*, and thereby blocking experimentation on that work-stream.\n\n## Implementation Summary\n\n- There is an ERC20-compatible contract that mints and owns an NFT upon deployment\n- The contract can have an owner, but the owner cannot `mint()` tokens — we might call this an *operator.* The operator can accept bids on the NFT, and can simultaneously close funding and withdraw the funds that were raised.\n- Contributors are able to send funds (e.g. ETH) to the contract in exchange for a proportional ownership stake in the future work.\n- Contributors are able to exit by using a method that burns their equity tokens and sends them their funds (initial contribution + profits)\n- The contract has a \"hard cap\", beyond which nobody else can join the crowdfund.\n    - This limits the original valuation for the NFT to something less than the expected profitability, limits exploitation of vulnerabilities, and also creates some scarcity around being part of the funding opportunity.\n    - The downside is that one person might just buy all of it, which is less fun.\n\n## Potential Downsides\n\n- It could have a vulnerability, and lose funds.\n\n## Implementation Details\n\nBasic sketch of the contract (please do not use in production, this is just a sketch and not intended to compile).\n\n```js\n// A completely untested sketch of a contract, written in a Notion doc.\ncontract Crowdfund is ERC20 {\n    using SafeMath for uint256;\n\n    // A list of possible states for crowd-funding.\n    enum Status {FUNDING, TRADING}\n    // The actual status of the crowd-fund, one of `Status`.\n    Status internal _status;\n\n    // Events representing crowdfunding life-cycle.\n    event FundingOpened(\n        address media,\n        address creator,\n        uint256 creatorEquityPercent\n    );\n    event Contribution(address contributor, uint256 amount);\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\n    event BidAccepted(uint256 amount);\n    event Withdrawal(address contributor, uint256 amount);\n\n    // The NFT's information.\n    address private _nftAddress;\n    uint256 _tokenId;\n\n    // Creator's information.\n    // John is the artist and controls this contract.\n    address private _johns_address;\n    uint256 _johns_equity_percent;\n\n    // Cap it at 10 ETH.\n    uint256 private _funding_cap_eth = 10;\n\n    modifier onlyJohn() {\n        require(msg.sender == _johns_address);\n        _;\n    }\n\n    constructor(\n        address johns_address,\n        address mediaAddress,\n        Data memory nftData,\n        uint256 johns_equity_percent,\n        address WETH_\n    ) public ERC20(\"John's Crowdfund\", \"JOHN\") {\n        _nftAddress = mediaAddress;\n\n        // TODO: Mint an NFT with the owner being this contract, using\n        // using nftData.\n\n        _johns_address = johns_address;\n        _johns_equity_percent = johns_equity_percent;\n\n        _status = Status.FUNDING;\n\n        emit FundingOpened(_nftAddress, _johns_address, _johns_equity_percent);\n    }\n\n    /*\n        Contributor Crowdfunding Methods\n     */\n\n    function contribute(uint256 amount) external {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        uint256 currentBalance = balanceOf(address(this));\n        require(\n            amount.add(currentBalance) < _funding_cap_eth.mul(1e18),\n            \"Total contributions would exceed funding cap\"\n        );\n\n        // Pull funds from the contributor to this contract.\n        require(\n            transferFrom(msg.sender, address(this), amount),\n            \"Contribution Failed\"\n        );\n\n        // Mint equity for the contributor.\n        _mint(msg.sender, amount);\n\n        emit Contribution(msg.sender, amount);\n    }\n\n    // The contributor can withdrawl at any time for their percent\n    // of the pool.\n    function withdraw(uint256 tokenAmount) external {\n        uint256 percentStake = tokenAmount.div(totalSupply());\n        uint256 withdrawAmount = percentStake.mul(balanceOf(address(this)));\n\n        _burn(msg.sender, tokenAmount);\n\n        require(transfer(msg.sender, withdrawAmount), \"Withdraw failed\");\n\n        emit Withdrawal(msg.sender, withdrawAmount);\n    }\n\n    /*\n        Operational Methods\n    */\n\n    function closeFunding() external onlyJohn {\n        require(_status == Status.FUNDING, \"Status must be funding\");\n\n        // Transfer all funds to John.\n        uint256 amountRaised = balanceOf(address(this));\n        require(transfer(_johns_address, amountRaised), \"Withdraw failed\");\n\n        // Mint John some percent of the total supply.\n        // For example, if the total supply is 3 ETH, and\n        // John is set to get 5%, then he will get 0.15 ETH.\n        // 3 / 100 * 5 = 0.15.\n        uint256 tokensForJohn =\n            totalSupply().div(100).mul(_johns_equity_percent);\n        _mint(_johns_address, tokensForJohn);\n\n        // Close funding status, move to tradable.\n        _status = Status.TRADING;\n\n        emit FundingClosed(amountRaised, tokensForJohn);\n    }\n\n    // As the operator, John is allowed to accept a bid for the\n    // NFT from the market. This should increase the money in the contract.\n    function acceptNFTBid(Bid calldata bid) external onlyJohn {\n        require(_status == Status.TRADING, \"Status must be trading\");\n\n        // TODO: Accept a bid from an NFT market, thereby\n        // receiving funds. Unwrap WETH if necessary.\n\n        emit BidAccepted(bid.amount);\n    }\n\n    /*\n        Miscellaneous operational functions, e.g. update NFT data.\n    */\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenURI(string calldata tokenURI) external onlyJohn {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    // Allows John to update metadata associated with the NFT.\n    function updateTokenMetadataURI(string calldata metadataURI)\n        external\n        onlyJohn\n    {\n        // Update data on the NFT.\n        // TODO: Emit event.\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        assert(msg.sender == WETH);\n    }\n}\n```\n\nPlease comment with feedback on this thread:\n\n[](https://twitter.com/viamirror/status/1351989735191937027)", "timestamp": 1611181205, "digest": "llJ_AboiDJwB_ZAFz-CXU7fL2p8v5Wz6MjfluLafewQ", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
