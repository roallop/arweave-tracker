{"id": "BFVpa5ls-OStBdQEWp_p6FBrwuh9atOtuS1-TdlStzM", "title": "Formatting Design", "body": "- Hey there\n- Another one\n- [Great](https://google.com) stuff\n\n![This is a **test** for [markdown](http://google.com)](https://images.mirror-media.xyz/publication-images/02196a8d-2949-417b-b1b2-85d8eb75f378.jpeg)\n\nAwesome.", "timestamp": 1609870782, "digest": "B32AHYVIlCf20jjOc7ebm3dv1W7KIBjdw9JB93z3gKY", "contributor": "0x841fF85B6873d7bfB712C8f7A347C774355b6EC3"}
{"id": "FQJF4ajpwbCTGxedctItSCR6UpYPVjx5KEAGtaE6PbQ", "title": "RFC: Signing Data", "body": "\nWritten by: [@Graeme](https://g.mirror.xyz)\n\n## Status\n\nImplemented\n\n## Summary\n\n- On \"signup\", we will generate a **signing key**, using a well audited open source crypto library such as the natively implemented *SubtleCrypto*. We will use the Ethereum private key *that owns the publication* to **sign this signing key** and we will store and publish that as an attestation linking the ENS domain to any Entry published by that signing key**.**\n    - The client can store the signing key in IndexedDB, perhaps encrypted with a password, and the client can use this key to sign data any that we want to store. We will publish the signature that connects the Ethereum address to the signing key, thereby proving that this signing key was authorized by the owner of the publication.\n    - Note: This means that the client browser always has access to an encrypted signing key via IndexedDB when they're on the domain where they first logged in. If encrypted, the user has to \"log in\" with a password to decrypt that key. This is similar to how Metamask uses a password for their \"KeyRing\" scheme. In contrast to MetaMask, in our scheme, the signing key can never hold funds, because it's not an Ethereum address.\n\n- When the user wants to use a different browser that does not have a signing key on it, or for some other reason loses their signing key, we will generate a new key, sign it with the Ethereum ownership key, and store that. A user can therefore have multiple signing keys.\n- Keys can be revoked via \"log out\" ‚Äî i.e. destroying the signing key in storage, or (in a later version) by signing a message that explicitly revokes the key and storing that on Arweave (in the case of a compromise). Clients will need to respect this revocation.\n\nThe UX for the signing mechanic is similar to something Cryptokitties does, and our language could read something like \"I authorize the publication of articles on [diff.mirror.xyz](http://diff.mirror.xyz) from this device, using the public address {x}\".\n\n![Metamask Signing Example](https://images.mirror-media.xyz/publication-images/d533bfff-6a13-4d71-bbe5-0cb784e0b158.jpeg)\n\n## Rationale\n\n- In order to sign an entry for `publication`, we must prove ownership of the publication to which it is submitted.\n- Signing using a separate \"signing key\", rather than the Ethereum private key itself gives the client **more flexibility to store these keys without risking funds** on Ethereum.\n- Having the signing key be a well-supported standard, as opposed to Ethereum keys themselves, allows more robust client-server interactions.\n\n## Alternatives\n\n- Have every interaction signed by the Ethereum owner address\n    - This creates a cumbersome UX.\n- Store an Ethereum address as the signing key\n    - Doesn't really confer any benefit, and it could be confusing for a user if they know.\n    - WebCrypto doesn't work with Ethereum addresses*, and we want to use WebCrypto if we're storing keys locally. *Specifically: WebCrypto does contain a CryptoKey ECDSA type, but it does not support the secp256k1 curve used in Ethereum; instead it uses the NIST secp256r1 curve.\n\n## Potential Downsides\n\n- To be discussed synchronously.\n\n## Engineering Implementation\n\nHere I'll compile scripts for generating keys, storing keys, signing keys, signing entries, etc.\n\n**Note about ECDSA signatures specifically**: It looks like some people using Firefox and Safari are having problems storing ECDSA keys in IndexedDB via a popular storage libraries, so we might want to walk through our full options: \n\n- [https://github.com/localForage/localForage/issues/844](https://github.com/localForage/localForage/issues/844)\n- [https://github.com/fission-suite/keystore-idb/issues/1](https://github.com/fission-suite/keystore-idb/issues/1)\n\n### Key Generation\n\nCreate a new keypair using ECDSA, and make it non-extractable (i.e. it can only sign messages).\n\n```jsx\nwindow.crypto.subtle.generateKey(\n    {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\", //can be \"P-256\", \"P-384\", or \"P-521\"\n    },\n    false, //whether the key is extractable (i.e. can be used in exportKey)\n    [\"sign\", \"verify\"] //can be any combination of \"sign\" and \"verify\"\n)\n.then(function(key){\n    //returns a keypair object\n    console.log(key);\n    console.log(key.publicKey);\n    console.log(key.privateKey);\n\t\t// This would be the place to store the key in IndexedDB.\n})\n.catch(function(err){\n    console.error(err);\n});\n```\n\n### Storing the Keys\n\nThe actual data for the private key shouldn't be extractable. We can then store the key in IndexedDB. We can also consider encrypting it with a password before we store it.\n\n**Note**: IndexDB has same-origin policy for accessing data, so the signing key will only be accessible by the same domain where it was created!\n\nMore from [developer.mozilla.org](http://developer.mozilla.org) that tells us we should use IndexedDB:\n\n> CryptoKey objects can be stored using the structured clone algorithm, meaning that you can store and retrieve them using standard web storage APIs. **The specification expects that most developers will use the IndexedDB API to store CryptoKey objects.**\n\nSo CryptoKeys are really meant to be stored here in IndexedDB.\n\nLet's use a small library for doing this:\n\n```jsx\nnpm install idb\n```\n\nLet's create a DB and store the private key there.\n\n```jsx\nimport { openDB, deleteDB, wrap, unwrap } from 'idb';\n\nconst dbName = \"MirrorXYZ\";\nconst version = 1;\n\nconst tableName = \"signingKeys\";\n\nconst db = await openDB(dbName, version, {\n\t// First the first call, or upgrades, we define the schema.\n  upgrade(db) {\n    // Create a store of objects\n    const store = db.createObjectStore(tableName, {\n      // The 'id' property of the object will be the key.\n      keyPath: 'id',\n      // If it isn't explicitly set, create a value by auto incrementing.\n      autoIncrement: true,\n    });\n    // Create an index on the 'publicKey' property of the objects.\n    store.createIndex('publicKey', 'publicKey');\n  },\n});\n\n// Store the key we generated to the signingKeys table, along with the date.\nawait db.add(tableName, {\n\t...key, // publicKey, privateKey\n  date: new Date(),\n});\n\n// Get all the signingKeys in date order:\nconsole.log(await db.getAllFromIndex(tableName, date));\n```\n\n### Signing the Signing Key with Ethereum Key\n\nThis verifies that the Ethereum address that owns the ENS Label attests to this signing key. There are lots of examples and libraries that explain how to do this! So this is just one example, using Eth.js:\n\n```jsx\n\nfunction connect () {\n  if (typeof ethereum !== 'undefined') {\n    ethereum.enable()\n    .catch(console.error)\n  }\n}\n\nconst msg = ethUtil.bufferToHex(new Buffer(text, 'utf8'));\nconst var from = web3.eth.accounts[0];\n\nif (!from) return connect();\n\nconst params = [from, msg]\n\n// Using Eth.js\nconst eth = new Eth(web3.currentProvider)\n\neth.personal_sign(msg, from)\n  .then((signed) => {\n\t\t// Now we have the signed message, we should send this to the\n\t\t// server. I think we could also store this in IndexedDB.\n    console.log('Signed!  Result is: ', signed);\n\n\t\t// We can  alsoverify that this address can recover the original message.\n    return eth.personal_ecRecover(msg, signed)\n  })\n  .then((recovered) => {\n\t\t// recovered here will be the sender's address, if it recovered correctly.\n    if (recovered === from) {\n      console.log('Ethjs recovered the message signer!')\n    } else {\n      console.log('Ethjs failed to recover the message signer!')\n    }\n  });\n```\n\n### Signing an Entry with the Signing Key\n\nThis verifies that a signing key has committed to the entry. There are lots of examples of how to do this here: [https://github.com/diafygi/webcrypto-examples](https://github.com/diafygi/webcrypto-examples)\n\n```jsx\nwindow.crypto.subtle.sign(\n    {\n        name: \"ECDSA\",\n        hash: {name: \"SHA-256\"}, //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n    },\n    privateKey, // from what we stored in IndexedDB.\n    data //ArrayBuffer of data you want to sign\n)\n.then(function(signature){\n    // returns an ArrayBuffer containing the signature\n    console.log(new Uint8Array(signature));\n})\n.catch(function(err){\n    console.error(err);\n});\n```\n\n### Password Protection (NOTE: This might not be needed)\n\nEncrypt the key with a password. This would protect a user in the case of an attacker actually having their computer. Could use a variety of strategies here.\n\n```jsx\n// The same library used by MetaMask; a very simple one using\n// the browser's native crypto library.\nconst encryptor = require('browser-passworder');\n\n// After generating the signing key, create an object that contains it.\nconst keyData = { ... };\n\n// Encrypt that data with a password.\nconst encryptedKeyData = encryptor.encrypt(password, keyData);\n```\n\nDecrypt the key with a password:\n\n```jsx\n// Whenever we need to access it, decrypt it with the password.\nconst decryptedKeyData = await encryptor.decrypt(password, encryptedKeyData);\n```", "timestamp": 1609911841, "digest": "1cywoB2BSXKRdJPA26NmH26AvuIbTJ0p8rYf7KaKktc", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "zfCeoPvujGuv0lLdYUE8SRPoIhRpIx9WOxY7KlxnAxI", "title": "RFC: Signing Data", "body": "## Summary\n\n- On \"signup\", we will generate a **signing key**, using a well audited open source crypto library such as the natively implemented *SubtleCrypto*. We will use the Ethereum private key *that owns the publication* to **sign this signing key** and we will store and publish that as an attestation linking the ENS domain to any Entry published by that signing key**.**\n    - The client can store the signing key in IndexedDB, perhaps encrypted with a password, and the client can use this key to sign data any that we want to store. We will publish the signature that connects the Ethereum address to the signing key, thereby proving that this signing key was authorized by the owner of the publication.\n    - Note: This means that the client browser always has access to an encrypted signing key via IndexedDB when they're on the domain where they first logged in. If encrypted, the user has to \"log in\" with a password to decrypt that key. This is similar to how Metamask uses a password for their \"KeyRing\" scheme. In contrast to MetaMask, in our scheme, the signing key can never hold funds, because it's not an Ethereum address.\n\n- When the user wants to use a different browser that does not have a signing key on it, or for some other reason loses their signing key, we will generate a new key, sign it with the Ethereum ownership key, and store that. A user can therefore have multiple signing keys.\n- Keys can be revoked via \"log out\" ‚Äî i.e. destroying the signing key in storage, or (in a later version) by signing a message that explicitly revokes the key and storing that on Arweave (in the case of a compromise). Clients will need to respect this revocation.\n\nThe UX for the signing mechanic is similar to something Cryptokitties does, and our language could read something like \"I authorize the publication of articles on [diff.mirror.xyz](http://diff.mirror.xyz) from this device, using the public address {x}\".\n\n![Metamask Signing Example](https://images.mirror-media.xyz/publication-images/d533bfff-6a13-4d71-bbe5-0cb784e0b158.jpeg)\n\n## Rationale\n\n- In order to sign an entry for `publication`, we must prove ownership of the publication to which it is submitted.\n- Signing using a separate \"signing key\", rather than the Ethereum private key itself gives the client **more flexibility to store these keys without risking funds** on Ethereum.\n- Having the signing key be a well-supported standard, as opposed to Ethereum keys themselves, allows more robust client-server interactions.\n\n## Alternatives\n\n- Have every interaction signed by the Ethereum owner address\n    - This creates a cumbersome UX.\n- Store an Ethereum address as the signing key\n    - Doesn't really confer any benefit, and it could be confusing for a user if they know.\n    - WebCrypto doesn't work with Ethereum addresses*, and we want to use WebCrypto if we're storing keys locally. *Specifically: WebCrypto does contain a CryptoKey ECDSA type, but it does not support the secp256k1 curve used in Ethereum; instead it uses the NIST secp256r1 curve.\n\n## Potential Downsides\n\n- To be discussed synchronously.\n\n## Engineering Implementation\n\nHere I'll compile scripts for generating keys, storing keys, signing keys, signing entries, etc.\n\n**Note about ECDSA signatures specifically**: It looks like some people using Firefox and Safari are having problems storing ECDSA keys in IndexedDB via a popular storage libraries, so we might want to walk through our full options: \n\n- [https://github.com/localForage/localForage/issues/844](https://github.com/localForage/localForage/issues/844)\n- [https://github.com/fission-suite/keystore-idb/issues/1](https://github.com/fission-suite/keystore-idb/issues/1)\n\n### Key Generation\n\nCreate a new keypair using ECDSA, and make it non-extractable (i.e. it can only sign messages).\n\n```jsx\nwindow.crypto.subtle.generateKey(\n    {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\", //can be \"P-256\", \"P-384\", or \"P-521\"\n    },\n    false, //whether the key is extractable (i.e. can be used in exportKey)\n    [\"sign\", \"verify\"] //can be any combination of \"sign\" and \"verify\"\n)\n.then(function(key){\n    //returns a keypair object\n    console.log(key);\n    console.log(key.publicKey);\n    console.log(key.privateKey);\n\t\t// This would be the place to store the key in IndexedDB.\n})\n.catch(function(err){\n    console.error(err);\n});\n```\n\n### Storing the Keys\n\nThe actual data for the private key shouldn't be extractable. We can then store the key in IndexedDB. We can also consider encrypting it with a password before we store it.\n\n**Note**: IndexDB has same-origin policy for accessing data, so the signing key will only be accessible by the same domain where it was created!\n\nMore from [developer.mozilla.org](http://developer.mozilla.org) that tells us we should use IndexedDB:\n\n> CryptoKey objects can be stored using the structured clone algorithm, meaning that you can store and retrieve them using standard web storage APIs. **The specification expects that most developers will use the IndexedDB API to store CryptoKey objects.**\n\nSo CryptoKeys are really meant to be stored here in IndexedDB.\n\nLet's use a small library for doing this:\n\n```jsx\nnpm install idb\n```\n\nLet's create a DB and store the private key there.\n\n```jsx\nimport { openDB, deleteDB, wrap, unwrap } from 'idb';\n\nconst dbName = \"MirrorXYZ\";\nconst version = 1;\n\nconst tableName = \"signingKeys\";\n\nconst db = await openDB(dbName, version, {\n\t// First the first call, or upgrades, we define the schema.\n  upgrade(db) {\n    // Create a store of objects\n    const store = db.createObjectStore(tableName, {\n      // The 'id' property of the object will be the key.\n      keyPath: 'id',\n      // If it isn't explicitly set, create a value by auto incrementing.\n      autoIncrement: true,\n    });\n    // Create an index on the 'publicKey' property of the objects.\n    store.createIndex('publicKey', 'publicKey');\n  },\n});\n\n// Store the key we generated to the signingKeys table, along with the date.\nawait db.add(tableName, {\n\t...key, // publicKey, privateKey\n  date: new Date(),\n});\n\n// Get all the signingKeys in date order:\nconsole.log(await db.getAllFromIndex(tableName, date));\n```\n\n### Signing the Signing Key with Ethereum Key\n\nThis verifies that the Ethereum address that owns the ENS Label attests to this signing key. There are lots of examples and libraries that explain how to do this! So this is just one example, using Eth.js:\n\n```jsx\n\nfunction connect () {\n  if (typeof ethereum !== 'undefined') {\n    ethereum.enable()\n    .catch(console.error)\n  }\n}\n\nconst msg = ethUtil.bufferToHex(new Buffer(text, 'utf8'));\nconst var from = web3.eth.accounts[0];\n\nif (!from) return connect();\n\nconst params = [from, msg]\n\n// Using Eth.js\nconst eth = new Eth(web3.currentProvider)\n\neth.personal_sign(msg, from)\n  .then((signed) => {\n\t\t// Now we have the signed message, we should send this to the\n\t\t// server. I think we could also store this in IndexedDB.\n    console.log('Signed!  Result is: ', signed);\n\n\t\t// We can  alsoverify that this address can recover the original message.\n    return eth.personal_ecRecover(msg, signed)\n  })\n  .then((recovered) => {\n\t\t// recovered here will be the sender's address, if it recovered correctly.\n    if (recovered === from) {\n      console.log('Ethjs recovered the message signer!')\n    } else {\n      console.log('Ethjs failed to recover the message signer!')\n    }\n  });\n```\n\n### Signing an Entry with the Signing Key\n\nThis verifies that a signing key has committed to the entry. There are lots of examples of how to do this here: [https://github.com/diafygi/webcrypto-examples](https://github.com/diafygi/webcrypto-examples)\n\n```jsx\nwindow.crypto.subtle.sign(\n    {\n        name: \"ECDSA\",\n        hash: {name: \"SHA-256\"}, //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n    },\n    privateKey, // from what we stored in IndexedDB.\n    data //ArrayBuffer of data you want to sign\n)\n.then(function(signature){\n    // returns an ArrayBuffer containing the signature\n    console.log(new Uint8Array(signature));\n})\n.catch(function(err){\n    console.error(err);\n});\n```\n\n### Password Protection (NOTE: This might not be needed)\n\nEncrypt the key with a password. This would protect a user in the case of an attacker actually having their computer. Could use a variety of strategies here.\n\n```jsx\n// The same library used by MetaMask; a very simple one using\n// the browser's native crypto library.\nconst encryptor = require('browser-passworder');\n\n// After generating the signing key, create an object that contains it.\nconst keyData = { ... };\n\n// Encrypt that data with a password.\nconst encryptedKeyData = encryptor.encrypt(password, keyData);\n```\n\nDecrypt the key with a password:\n\n```jsx\n// Whenever we need to access it, decrypt it with the password.\nconst decryptedKeyData = await encryptor.decrypt(password, encryptedKeyData);\n```", "timestamp": 1609912129, "digest": "1cywoB2BSXKRdJPA26NmH26AvuIbTJ0p8rYf7KaKktc", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "26cEgbPeFSpTtXKm30jZXDNlV6aSSBs82uis4-klkMQ", "title": "RFC: Signing Data", "body": "- On \"signup\", we will generate a **signing key**, using a well audited open source crypto library such as the natively implemented *SubtleCrypto*. We will use the Ethereum private key *that owns the publication* to **sign this signing key** and we will store and publish that as an attestation linking the ENS domain to any Entry published by that signing key**.**\n    - The client can store the signing key in IndexedDB, perhaps encrypted with a password, and the client can use this key to sign data any that we want to store. We will publish the signature that connects the Ethereum address to the signing key, thereby proving that this signing key was authorized by the owner of the publication.\n    - Note: This means that the client browser always has access to an encrypted signing key via IndexedDB when they're on the domain where they first logged in. If encrypted, the user has to \"log in\" with a password to decrypt that key. This is similar to how Metamask uses a password for their \"KeyRing\" scheme. In contrast to MetaMask, in our scheme, the signing key can never hold funds, because it's not an Ethereum address.\n\n- When the user wants to use a different browser that does not have a signing key on it, or for some other reason loses their signing key, we will generate a new key, sign it with the Ethereum ownership key, and store that. A user can therefore have multiple signing keys.\n- Keys can be revoked via \"log out\" ‚Äî i.e. destroying the signing key in storage, or (in a later version) by signing a message that explicitly revokes the key and storing that on Arweave (in the case of a compromise). Clients will need to respect this revocation.\n\nThe UX for the signing mechanic is similar to something Cryptokitties does, and our language could read something like \"I authorize the publication of articles on [diff.mirror.xyz](http://diff.mirror.xyz) from this device, using the public address {x}\".\n\n![Metamask Signing Example](https://images.mirror-media.xyz/publication-images/d533bfff-6a13-4d71-bbe5-0cb784e0b158.jpeg)\n\n## Rationale\n\n- In order to sign an entry for `publication`, we must prove ownership of the publication to which it is submitted.\n- Signing using a separate \"signing key\", rather than the Ethereum private key itself gives the client **more flexibility to store these keys without risking funds** on Ethereum.\n- Having the signing key be a well-supported standard, as opposed to Ethereum keys themselves, allows more robust client-server interactions.\n\n## Alternatives\n\n- Have every interaction signed by the Ethereum owner address\n    - This creates a cumbersome UX.\n- Store an Ethereum address as the signing key\n    - Doesn't really confer any benefit, and it could be confusing for a user if they know.\n    - WebCrypto doesn't work with Ethereum addresses*, and we want to use WebCrypto if we're storing keys locally. *Specifically: WebCrypto does contain a CryptoKey ECDSA type, but it does not support the secp256k1 curve used in Ethereum; instead it uses the NIST secp256r1 curve.\n\n## Potential Downsides\n\n- To be discussed synchronously.\n\n## Engineering Implementation\n\nHere I'll compile scripts for generating keys, storing keys, signing keys, signing entries, etc.\n\n**Note about ECDSA signatures specifically**: It looks like some people using Firefox and Safari are having problems storing ECDSA keys in IndexedDB via a popular storage libraries, so we might want to walk through our full options: \n\n- [https://github.com/localForage/localForage/issues/844](https://github.com/localForage/localForage/issues/844)\n- [https://github.com/fission-suite/keystore-idb/issues/1](https://github.com/fission-suite/keystore-idb/issues/1)\n\n### Key Generation\n\nCreate a new keypair using ECDSA, and make it non-extractable (i.e. it can only sign messages).\n\n```jsx\nwindow.crypto.subtle.generateKey(\n    {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\", //can be \"P-256\", \"P-384\", or \"P-521\"\n    },\n    false, //whether the key is extractable (i.e. can be used in exportKey)\n    [\"sign\", \"verify\"] //can be any combination of \"sign\" and \"verify\"\n)\n.then(function(key){\n    //returns a keypair object\n    console.log(key);\n    console.log(key.publicKey);\n    console.log(key.privateKey);\n\t\t// This would be the place to store the key in IndexedDB.\n})\n.catch(function(err){\n    console.error(err);\n});\n```\n\n### Storing the Keys\n\nThe actual data for the private key shouldn't be extractable. We can then store the key in IndexedDB. We can also consider encrypting it with a password before we store it.\n\n**Note**: IndexDB has same-origin policy for accessing data, so the signing key will only be accessible by the same domain where it was created!\n\nMore from [developer.mozilla.org](http://developer.mozilla.org) that tells us we should use IndexedDB:\n\n> CryptoKey objects can be stored using the structured clone algorithm, meaning that you can store and retrieve them using standard web storage APIs. **The specification expects that most developers will use the IndexedDB API to store CryptoKey objects.**\n\nSo CryptoKeys are really meant to be stored here in IndexedDB.\n\nLet's use a small library for doing this:\n\n```jsx\nnpm install idb\n```\n\nLet's create a DB and store the private key there.\n\n```jsx\nimport { openDB, deleteDB, wrap, unwrap } from 'idb';\n\nconst dbName = \"MirrorXYZ\";\nconst version = 1;\n\nconst tableName = \"signingKeys\";\n\nconst db = await openDB(dbName, version, {\n\t// First the first call, or upgrades, we define the schema.\n  upgrade(db) {\n    // Create a store of objects\n    const store = db.createObjectStore(tableName, {\n      // The 'id' property of the object will be the key.\n      keyPath: 'id',\n      // If it isn't explicitly set, create a value by auto incrementing.\n      autoIncrement: true,\n    });\n    // Create an index on the 'publicKey' property of the objects.\n    store.createIndex('publicKey', 'publicKey');\n  },\n});\n\n// Store the key we generated to the signingKeys table, along with the date.\nawait db.add(tableName, {\n\t...key, // publicKey, privateKey\n  date: new Date(),\n});\n\n// Get all the signingKeys in date order:\nconsole.log(await db.getAllFromIndex(tableName, date));\n```\n\n### Signing the Signing Key with Ethereum Key\n\nThis verifies that the Ethereum address that owns the ENS Label attests to this signing key. There are lots of examples and libraries that explain how to do this! So this is just one example, using Eth.js:\n\n```jsx\n\nfunction connect () {\n  if (typeof ethereum !== 'undefined') {\n    ethereum.enable()\n    .catch(console.error)\n  }\n}\n\nconst msg = ethUtil.bufferToHex(new Buffer(text, 'utf8'));\nconst var from = web3.eth.accounts[0];\n\nif (!from) return connect();\n\nconst params = [from, msg]\n\n// Using Eth.js\nconst eth = new Eth(web3.currentProvider)\n\neth.personal_sign(msg, from)\n  .then((signed) => {\n\t\t// Now we have the signed message, we should send this to the\n\t\t// server. I think we could also store this in IndexedDB.\n    console.log('Signed!  Result is: ', signed);\n\n\t\t// We can  alsoverify that this address can recover the original message.\n    return eth.personal_ecRecover(msg, signed)\n  })\n  .then((recovered) => {\n\t\t// recovered here will be the sender's address, if it recovered correctly.\n    if (recovered === from) {\n      console.log('Ethjs recovered the message signer!')\n    } else {\n      console.log('Ethjs failed to recover the message signer!')\n    }\n  });\n```\n\n### Signing an Entry with the Signing Key\n\nThis verifies that a signing key has committed to the entry. There are lots of examples of how to do this here: [https://github.com/diafygi/webcrypto-examples](https://github.com/diafygi/webcrypto-examples)\n\n```jsx\nwindow.crypto.subtle.sign(\n    {\n        name: \"ECDSA\",\n        hash: {name: \"SHA-256\"}, //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n    },\n    privateKey, // from what we stored in IndexedDB.\n    data //ArrayBuffer of data you want to sign\n)\n.then(function(signature){\n    // returns an ArrayBuffer containing the signature\n    console.log(new Uint8Array(signature));\n})\n.catch(function(err){\n    console.error(err);\n});\n```\n\n### Password Protection (NOTE: This might not be needed)\n\nEncrypt the key with a password. This would protect a user in the case of an attacker actually having their computer. Could use a variety of strategies here.\n\n```jsx\n// The same library used by MetaMask; a very simple one using\n// the browser's native crypto library.\nconst encryptor = require('browser-passworder');\n\n// After generating the signing key, create an object that contains it.\nconst keyData = { ... };\n\n// Encrypt that data with a password.\nconst encryptedKeyData = encryptor.encrypt(password, keyData);\n```\n\nDecrypt the key with a password:\n\n```jsx\n// Whenever we need to access it, decrypt it with the password.\nconst decryptedKeyData = await encryptor.decrypt(password, encryptedKeyData);\n```", "timestamp": 1609912662, "digest": "1cywoB2BSXKRdJPA26NmH26AvuIbTJ0p8rYf7KaKktc", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "1T8viKPujC2C36SMEnwawXjanc5gvXKgjlXC4BUFGXE", "title": "Daily Log - 05.01.2020", "body": "My goals today were to:\n\n- Set up a dev blog, which we will use to further our efforts to work \"in public\"\n- Write the first blog post for the dev blog, detailing our first month and the launch of our MVP\n- RFC a new way to store Entries in our API backend (which solved a few of the outstanding issues from the MVP launch)\n- Kick off the technical introduction with Zora about future integrations\n\nI also had in mind the goal to be more communicative with the team about when I'm online and available for discussions (given that we're all remote, Slack is basically the only forum at which to reach me). I implemented a small change in Slack to make this more formal, creating a *whereabouts* channel that I can use to be more explicit about when I'm away or particularly focused and not available for discussion.\n\nAll of my goals were achieved, although they could have been much more efficient ‚Äî especially the meetings. Both of my meetings today took two hours, which indicates that formal goals and parameters we not laid out. The net effect of this meant that I ended working at around 12 AM. In future, we should set specific goals for meetings, and know when we've reached success or failed within a time-boxed frame (unless we're just jammin').\n\nI feel some urgency to get the Entry RFC implemented and merged soon, although it only serves to make our tech more robust, and doesn't necessarily move us forwards as a product. Therefore, implementation might need to be held off until later. This makes me uneasy, but it's fair. Instead, I will prioritize a brief personal audit of our security so far, and then attempt to dive into protocol work.\n\nThe 2-hour discussion with Zora about an integration with their new protocol implementation was fun, and I'm excited about what we can do. Immediately follow that, we had an internal meeting about our \"working in public\" blog strategy, and then how we might bring protocol and other web3 integrations into blog entries directly. \n\nThe idea of integrating web3 content directly into entries is super exciting, and I believe it will be a core feature of Mirror. Ecosystem-enabled, modular structures/blocks that have web3 functionality.\n\n![Denis hinting at where something like this might lead](https://images.mirror-media.xyz/publication-images/39f72ef6-8453-4228-a645-0a6d281b3e3d.jpeg)\n\nEven more exciting will be the opportunity to bring the community into the development of these features. If Notion has \"templates\" that users can buy on Gumroad, Mirror could have block-formats that people can buy on Uniswap. This requires a lot more thought, of course, but it's an interesting thread.\n\nAt the same time as we think through this, there is a strong internal desire at Mirror to have a great *writing experience*, and we need to be realistic about what we can ship in the near-term that's exciting and effective for our early writers. Both the time constraints and desire for world-class writing UX will likely sway us away from being too ambitious with our scope, and instead I can see us trying to work within existing standards (e.g. markdown), to hack together a prototype. The prototype will allow us to get more feedback and information, from which vantage point we can tackle the larger goal. This seems like a reasonable approach.\n\nI didn't get to more Mirror Protocol design work, but hopefully I can start that in earnest tomorrow, and have some validated new ideas by the end of the week.", "timestamp": 1609921907, "digest": "9Czd59-u4Ode2sQ2zzixDQal_nEfuzoURDILbOlgsKg", "contributor": "0xCC65fA278B917042822538c44ba10AD646824026"}
{"id": "Y65byW-fr9pt9gfUGbM_tpCEVD0Z0DKwEqV2HCG_bvo", "title": "Formatting Design", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs‚Äîbut we knew that the starting point for the project was supporting a basic publishing experience‚Äîthe ability to post text and share it with the world. \n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing shall not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, you can refer to an [internal RFC](https://eng.mirror.xyz/1cywoB2BSXKRdJPA26NmH26AvuIbTJ0p8rYf7KaKktc) about this topic, which has now been posted on Mirror.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered using writing the backend in Golang or Rust, and protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But I know that development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609963120, "digest": "B32AHYVIlCf20jjOc7ebm3dv1W7KIBjdw9JB93z3gKY", "contributor": "0x841fF85B6873d7bfB712C8f7A347C774355b6EC3"}
{"id": "olgScfABGbdDOWqjK_qNB3KjY41gAtvlddwew8QFq4I", "title": "The MVP Before Christmas", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs‚Äîbut we knew that the starting point for the project was supporting a basic publishing experience‚Äîthe ability to post text and share it with the world. \n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing shall not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, you can refer to an [internal RFC](https://eng.mirror.xyz/1cywoB2BSXKRdJPA26NmH26AvuIbTJ0p8rYf7KaKktc) about this topic, which has now been posted on Mirror.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered using writing the backend in Golang or Rust, and protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But I know that development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609964268, "digest": "J1RD6UQQbdmpCoXvWnuGIfe7WmrbVRdff5EqegO1RjI", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "QcNAxbE0qeWzNTmnYUYmel6ScQrElFUv1pZUXRkFbgw", "title": "The MVP Before Christmas", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs‚Äîbut we knew that the starting point for the project was supporting a basic publishing experience‚Äîthe ability to post text and share it with the world. \n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing shall not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, we will shortly release a more complete spec/RFC about this topic.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered using writing the backend in Golang or Rust, and protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But I know that development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609965297, "digest": "J1RD6UQQbdmpCoXvWnuGIfe7WmrbVRdff5EqegO1RjI", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "kV9VrawYbZcuYL-HP0r8Lp0eijYP3Z355Zh048CA3Zk", "title": "Last one", "body": "Maybe?\n\n- one\n- two\n- three\n\n1. nice\n2. one\n3. you know?", "timestamp": 1609967145, "digest": "cjOdwnwH1IA0P6Dup56KrsGEpXA4CNKz9kWqNTeHAWo", "contributor": "0x841fF85B6873d7bfB712C8f7A347C774355b6EC3"}
{"id": "TGUCPYAJKFfPVzVkDX5BajUarNMuTgIT7H-3pw2pRJc", "title": "The MVP Before Christmas", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs. We knew that the starting point for the project was supporting a basic publishing experience; the ability to post text and share it with the world.\n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing shall not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, we will shortly release a more complete spec/RFC about this topic.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered using writing the backend in Golang or Rust, and protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But I know that development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609973986, "digest": "J1RD6UQQbdmpCoXvWnuGIfe7WmrbVRdff5EqegO1RjI", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "D7DUFuaRHie0CmEkeIF_CWkdW0G1cpBZKzcdoTknmAY", "title": "The MVP Before Christmas", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs. We knew that the starting point for the project was supporting a basic publishing experience; the ability to post text and share it with the world.\n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing should not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, we will shortly release a more complete spec/RFC about this topic.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered using writing the backend in Golang or Rust, and protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But I know that development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609974170, "digest": "J1RD6UQQbdmpCoXvWnuGIfe7WmrbVRdff5EqegO1RjI", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "ArVdXnbSv0243A-rvvBH85ZUXz-WKnYPQMW8_jUKiEs", "title": "The MVP Before Christmas", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs. We knew that the starting point for the project was supporting a basic publishing experience; the ability to post text and share it with the world.\n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing should not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, we will shortly release a more complete spec/RFC about this topic.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered writing the backend in Golang or Rust, and protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But I know that development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609976133, "digest": "J1RD6UQQbdmpCoXvWnuGIfe7WmrbVRdff5EqegO1RjI", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "3P34TE82OjTW92BWpaKKov5zx5TSBN0qOInApg_CoHs", "title": "The MVP Before Christmas", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs. We knew that the starting point for the project was supporting a basic publishing experience; the ability to post text and share it with the world.\n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing shall not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, we will shortly release a more complete spec/RFC about this topic.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered using writing the backend in Golang or Rust, and using protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609976176, "digest": "J1RD6UQQbdmpCoXvWnuGIfe7WmrbVRdff5EqegO1RjI", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
{"id": "5jcMVbvljulkJH3M2UljKJZGdpM6g74lPAMxJ_vvX6Y", "title": "The MVP Before Christmas", "body": "Mirror has the ambitious vision of redefining publishing online by empowering writers with the tools offered by crypto. We are delighted to share that we've officially closed our first full-stack engineering sprint: the MVP of the Mirror blogging platform. This will allow us to onboard our first writers and serve as the foundation for all the functionality in the future.\n\nWe have a lot to figure out over the next few months and years‚Äîfrom discovering new crypto-native business models for creators to supporting basic things like embedding NFTs. We knew that the starting point for the project was supporting a basic publishing experience; the ability to post text and share it with the world.\n\nThis post details our journey so far.\n\n![Season‚Äôs Greetings!](https://images.mirror-media.xyz/publication-images/bb9a61e1-f524-4135-bae5-91ddf7f0a1e9.jpeg)\n\n## The Starting Line\n\nOur first commit to the backend API was 29 days ago, on December 7, 2020 ‚Äî my (Graeme's) first official day at Mirror. Denis had been speaking with [Trent](https://stateful.mirror.xyz/) about announcing his book on Mirror, and working with Jon-Kyle on designs and UI. We set an ambitious goal to have everything working for Trent by Christmas time ‚Äî our gift to the world! üéÅ \n\nTo ship the MVP, we needed to make crucial early technical decisions. Most importantly, how to create a world-class writing tool with a native web3 and crypto foundation.\n\n## How to Construct a Web3-Native Writing Platform\n\nOne of the first challenges was thinking through building the platform from a web3 perspective. Here are rules of the web3 game (*via negativa* style):\n\n1. Post content shall not be centralized\n2. The reading experience should not require trust in Mirror\n3. Mirror shall not own a writer's domain\n4. Writers do not need to connect their wallets and sign everything they write\n5. Mirror shall not attempt to store Ethereum private keys in the browser!\n6. Writing shall not be excessively expensive (for Mirror or writers)\n7. Bonus: No using email-password signup!\n\nThe architecture we came up with looks something like this:\n\n![](https://images.mirror-media.xyz/publication-images/4ad92c52-5226-40c1-b654-4bbfe905c278.jpeg)\n\nI will now briefly break down how we solved each of these problems.\n\n### 1. Post content shall not be centralized\n\nWe decided to use the **Arweave** data storage protocol to store user content. Arweave provides permanent storage of data for a one-time cost at upload time. The data posted to Arweave includes all of the information required to *retrieve* all entries for a publication (including any changes made), and to *verify* authorship authenticity. (We have plans to publish the protocol specification along with an open-source tool that can assist with this retrieval and verification process, so that it would be trivial to migrate off of Mirror if the time ever comes for that.)\n\n### 2. The reading experience should not require trust in Mirror\n\nAll entries are signed by a user's *signing key* (this is a non-Ethereum keypair that does not contain any direct economic value. I'll explain more on this later). The signature is then published to Arweave, along with the digest that was signed, and with the content that went into the digest. The *signing key* itself is put into a message that asserts authorship rights, which is then signed by the writer's Ethereum address. All of this information is stored on Arweave, along with the entry's content ‚Äî for every entry and update. Therefore, it's possible (and fairly easy) for anyone to verify whether an entry was authored by a given Ethereum account.\n\nWe're still iterating on this model, and it's obviously very early. Consider us in the \"testnet\" phase of this (along with everything else you read in this post).\n\n### 3. Mirror shall not own a writer's domain\n\nWe use ENS to provide domain ownership to the writer, who claims this ownership by burning an invite token (called $WRITE; expect more information on this soon) during onboarding. The process involves interacting with the $WRITE ERC20 token contract, which grants approval to an ENS registrar contract to burn the token just before registering the ENS label.\n\n### 4. Writers do not need to connect their wallets and sign everything they write\n\nWe didn't want to make it cumbersome to have to write an Entry on Mirror ‚Äî for example, needing to sign everything with their Ledger wallet (or Metamask). Particularly, because we imagine allowing users to take smaller and more frequent actions, too, like commenting on or liking someone else's entry. We still want to have superb security, but we deemed it to be dissuading if writers required their hardware wallet for writing.\n\n### 5. Mirror shall not attempt to store Ethereum private keys in the browser!\n\nIt's considered heresy to store a user's Ethereum private keys directly in the browser, and I would typically agree with that. It's not strictly true that you *couldn't* build a useful webapp this way (Dharma did it for a while), but the security burden will compound over time. This is mainly because there is no way to make and store a non-extractable Ethereum private key using the native web-crypto library; it doesn't support the same ECDSA curve. I don't know how this will play out in the future, but for now, I would say that this is something to avoid.\n\nWe avoid this security burden in two ways: \n\n1. By using a different signature scheme from the Ethereum implementation (we're using the NIST curve *P-256*), therefore making it impossible for the key to \"hold economic value\" at all, and sidestepping a major issue altogether. The worst case scenario, under the most severe threat model (e.g. a stolen computer), would be fraudulent authorship.\n2. By generating the key using the non-extractable property, and storing it in IndexDB. This means that there's no way to export the private key at all ‚Äî the private key can only be used to sign content on the webpage in which it is loaded, and IndexDB prevents it from being loaded on any website outside of mirror.xyz.\n\nI invite criticism on this approach. I am not a cryptography expert, and we're just trying to make an honest effort at a secure and usable platform that lives outside of the conventional standards of web2 that have been failing us. If you want a more detailed explanation of the approach, we will shortly release a more complete spec/RFC about this topic.\n\n### 6. Writing shall not be excessively expensive (for Mirror or writers)\n\nSolved by using Arweave! üéâ Very cheap (at the moment?) ‚Äî it's costing us about 0.00005 AR per blog post, which amounts to about $0.00015, at the current exchange rate.\n\n### 7. Bonus: No using email-password signup!\n\nSince we have signing keys and a signature-based authenticity model, we don't need to have login sessions, and we don't have anything to recover via email. In the future, it may be useful to allow for email notifications and email digests, but for now, it's interesting that there is no email confirmation required to use Mirror. This is the crypto-native way used by apps like Zerion and Zapper, and is the future of authentication on the web.\n\n(We make up for this lack of friction by adding a transaction confirmation in onboarding! üòÇ But even that, we will smooth out over time.)\n\n## Pre-Mainnet Testing\n\nMirror is still in its early stages, and we are using the Ethereum testnet infrastructure to explore our ideas. This allows us to run through complex protocol flows (like burning tokens, deploying contract, and registering ENS domains) very cheaply and with fast confirmation times. In particular, we're still exploring what the *mechanics* of our economic, naming and ownership protocol will be, as demand grows for a more sophisticated system. We're hoping to deploy to mainnet as soon as we know that migrating our early writers to this better protocol will be feasible and easy.\n\n## Building a Backend API as a \"Protocol Gateway\"\n\nIn order to facilitate a good reading and writing experience, we decided to build a backend API that can act as a *gateway* between client and protocol. This allows us to do things like signature verification before publishing to Arweave, or to pay for the Arweave publication ourselves and cache the entry content for extremely fast response-times. This allows us to have a world-class writing and reading experience, while still achieving all of our goals of content decentralization.\n\nIn terms of building this backend API in 2021, there were probably 10+ viable options for where to deploy code and just as many promising languages for its development. Picking early tools can be difficult! I ended up choosing something that was strongly within my realm of competency, and would also be easy for new engineers on our team to learn. I also chose what I believe to be the path of greatest extensibility and flexibility into the future, which for us meant building our backend in **NodeJS on AWS infrastructure**. The decision was not obvious, however, and I wanted to take into account the competencies we would be building as an engineering order in time to come.\n\nSetting up web applications on AWS is much more time consuming than using an abstracted service like Heroku or Vercel. Things like environments, databases, security groups, and deployments all have to be configured up individually. In the long-run, though, it grants more control, and this can be helpful for crypto applications that sometimes had non-standard concerns. It took me about 2 days to set up this infrastructure ‚Äî including security groups, IAM accounts, databases, staging and production environments, etc. But from here, I know that I have the world's best infrastructure behind us, without the platform risk of newer, less fully-featured services.\n\nWe use **Postgres via AWS's RDS service**, and VPC and security groups for communicating between **ElasticBeanstalk** and RDS. We used **GraphQL with Apollo** for our API endpoints.\n\nI'll note here that, for a while before committing to this path, I considered writing the backend in Golang or Rust, and using protobufs, since cryptographic signatures require strict typing for correct validation across platforms. But development would have been *a lot slower* if we had gone this path. On the other hand, building a competency in Rust from the start would have allowed us to track the growing number of interesting layer-2 integrations (which seems promising).\n\nOur deployments are handled through **Github workflows**, such that every push to our *staging* or *main* triggers an action on Github that deploys the application. To be clear, there is a *lot* that still needs to be improved here ‚Äî including blocking deploys on test suites passing, and measuring test coverage. We don't have full integration tests, e.g. against a built docker contains with exposed GraphQL endpoints.\n\n![The genesis entry](https://images.mirror-media.xyz/publication-images/7c3c118d-8dda-4f5d-9e80-6df764fd403c.jpeg)\n\n## Building a Frontend for Blogging\n\nWe decided to use Vercel and NextJS on the frontend, which has wildcard subdomain support, as well as support for statically rendered content. This has been great so far, because we get fast-loading, well-cached content that can be read easily by machines like social media platforms and search engines. It's also generally a fantastic product for managing staging environments, deployments, etc.\n\n## What went well?\n\nWe were able to get an MVP out *really* really quickly ‚Äî we made a goal to ship before Christmas, and only started building the backend some ways into December. So overall, it took us mere weeks to build a novel CMS that uses public-private key signatures to verify content, stores data in Postgres, stores data on Arweave, burns a token on Ethereum to claim ownership of an ENS label, validates ownership of that label, iterations on our signing model, and so on. \n\nHere's a few specific examples of these things:\n\n1. The first blog post by Trent: [https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525](https://stateful.mirror.xyz/a151ee1decb2028a8bb48277f6928c6f38319c32601dc1da1ee82acfcad2e525)\n2. A transaction that burns a $WRITE token and claims an ENS domain: [https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b](https://rinkeby.etherscan.io/tx/0x29b9d13187a2db64b7d85f4ff5be739729b07404fd1f5fce79b3bba13da7530b)\n3. An Arweave transaction that stores Linda's [post](https://linda.mirror.xyz/df649d61efb92c910464a4e74ae213c4cab150b9cbcc4b7fb6090fc77881a95d) forever, along with signatures that prove authorship: [https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA](https://viewblock.io/arweave/tx/WvwsHyKCjfkLoKNbNSGfoV-vaWrJa2PMYB_c3wucXUA)\n\nIt's exhausting even to think back through the past month and everything we've been able to build out! And the fact that this is *basically working* is very fun and exciting. I'm glad that we also did a fair amount of this \"in public\" and have screen recording our on-boarding sessions.\n\n## What went wrong?\n\nBy tackling so many challenges at once, it sometimes felt like there were an overwhelming number of important issues that urgently needed to be patched. Sometimes, that made it difficult for me to communicate priorities in linear way, so that we were all on the same page and rationally working together on the same thing. Given that that team hadn't worked together before this project, and are just learning about each of our distinct work and communication styles, there was considerable \"under-communication\" that we need to improve on.\n\nThe fast pace also created some disorder. For example, late one Thursday I was configuring the Github Workflows to deploy our AWS EB environment, and it was working well in staging. We didn't deploy to production over the weekend, and during that time I updated production to a whole new AWS EB environment. Our first deploy on Monday shipped to the *outdated* environment, and a bug manifested right before an [onboarding session](https://www.youtube.com/watch?v=8e9Fcf0DiOE)! We had to roll-back to prevent live-streaming a failed onboarding, and it was very confusing! We wrote our first post-mortem for this.\n\n## What lessons were learned?\n\nWe learned that we can really push hard and work quickly to make an ambitious goal a reality within a short timeframe. I think we proved that by hitting the December 25th deadline.\n\nWe also learned a lot about each each and our competencies (there's only three of us), and how we need to communicate with each other to build more trust and confidence in how things are going. That includes over-communicating more about expectations and responsibilities over the codebase and product, outstanding issues, priorities, and individual goals for any given sprint.\n\nExpect more information on $WRITE soon.\n\nIn the meantime, you can read the first entries published on Mirror over the past few weeks:\n\n- [https://stateful.mirror.xyz/](https://stateful.mirror.xyz/) by [@trent_vanepps](https://twitter.com/trent_vanepps)\n- [http://amorfati.mirror.xyz/](http://amorfati.mirror.xyz/) by [@apruden08](https://twitter.com/apruden08)\n- [https://joonian.mirror.xyz/](https://joonian.mirror.xyz/) by [@joonian](https://twitter.com/joonian)\n- [https://helloshreyas.mirror.xyz/](https://helloshreyas.mirror.xyz/) by [@HelloShreyas](https://twitter.com/HelloShreyas)\n- [https://g.mirror.xyz/](https://g.mirror.xyz/) by [@strangechances](https://twitter.com/strangechances)\n- [https://d.mirror.xyz/](https://d.mirror.xyz/) by [@Iiterature](https://twitter.com/Iiterature)", "timestamp": 1609976205, "digest": "J1RD6UQQbdmpCoXvWnuGIfe7WmrbVRdff5EqegO1RjI", "contributor": "0x9651B2a7Aa9ed9635cE896a1Af1a7d6294d5e902"}
